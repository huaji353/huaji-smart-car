C251 COMPILER V5.60.0,  command                                                            12/06/25  20:23:02  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE command
OBJECT MODULE PLACED IN .\out_file\command.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE ..\code\command.c LARGE NOALIAS WARNINGLEVEL(3) OPTIMIZE(1,SIZE) BROWS
                    -E INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver;..\
                    -user;..\code) DEBUG PRINT(.\out_file\command.lst) TABS(2) OBJECT(.\out_file\command.obj) 

stmt  level    source

    1          #include "zf_common_headfile.h"
    2          //æ¨ªç”µæ„Ÿ1 ç«–ç”µæ„Ÿ2 ç«–ç”µæ„Ÿ3 æ¨ªç”µæ„Ÿ4
    3          float inductance_horizontal_1,inductance_vertical_2,inductance_vertical_3,inductance_horizontal_4,inducta
             -nce_horizontal_middle;
    4          float vcc;
    5          uint8 encoder_integral_flag = 0;
    6          int16 L_encoder = 0;
    7          int16 R_encoder = 0;
    8          int16 encoder_data_dir_1 = 0;
    9          int16 encoder_data_dir_2 = 0;
   10          uint32 encoder_integral_1  = 0;
   11          uint32 encoder_integral_2  = 0;
   12          float speed_L,speed_R;//å·¦å³è½®ç›®æ ‡é€Ÿåº¦
   13          char txt[32];
   14          uint8 eeprom_PID[]={
   15          //è§’åº¦ç¯      Pé«˜ä½   Pä½ä½  Pä½2ä½       Ié«˜ä½  Iä½ä½  Iä½2ä½        Dé«˜ä½  Dä½ä½  Dä
             -½2ä½
   16                        0x00,  0x00,  0x00,        0x00,  0x00,  0x00,        0x00,  0x00,  0x00, 
   17          //è§’é€Ÿåº¦ç¯    Pé«˜ä½   Pä½ä½  Pä½2ä½       Ié«˜ä½  Iä½ä½  Iä½2ä½        Dé«˜ä½  Dä½ä½  D
             -ä½2ä½
   18                        0x00,  0x00,  0x00,        0x00,  0x00,  0x00,        0x00,  0x00,  0x00,
   19          //å·¦è½®ç”µæœº    Pé«˜ä½   Pä½ä½  Pä½2ä½       Ié«˜ä½  Iä½ä½  Iä½2ä½        Dé«˜ä½  Dä½ä½  D
             -ä½2ä½
   20                        0x00,  0x00,  0x00,        0x00,  0x00,  0x00,        0x00,  0x00,  0x00,
   21          //å³è½®ç”µæœº    Pé«˜ä½   Pä½ä½  Pä½2ä½       Ié«˜ä½  Iä½ä½  Iä½2ä½        Dé«˜ä½  Dä½ä½  D
             -ä½2ä½
   22                        0x00,  0x00,  0x00,        0x00,  0x00,  0x00,        0x00,  0x00,  0x00,
   23          //é¢„ç•™å‚æ•°                                                                               å¯åŠ¨è®¡æ•°
   24                        0x00,  0x00,  0x00,        0x00,  0x00,  0x00,        0x00,  0x00,  0x00,  0x00
   25          };//ç´¢å¼•è¯´æ˜ï¼š
   26          //eeprom_PID[0]~[8]ä¸ºè§’åº¦ç¯P,I,Då‚æ•°
   27          //eeprom_PID[9]~[17]ä¸ºè§’é€Ÿåº¦ç¯P,I,Då‚æ•°
   28          //eeprom_PID[18]~[26]ä¸ºå·¦è½®ç”µæœºç¯P,I,Då‚æ•°
   29          //eeprom_PID[27]~[35]ä¸ºå³è½®ç”µæœºç¯P,I,Då‚æ•°
   30          //eeprom_PID[36]~[44]ä¸ºé¢„ç•™å‚æ•°
   31          //eeprom_PID[45]ä¸ºå¯åŠ¨è®¡æ•°
   32          uint8 inductance_max_min[]={
   33          //  æ¨ªç”µæ„Ÿ1æœ€å¤§å€¼          ç«–ç”µæ„Ÿ2æœ€å¤§å€¼            ç«–ç”µæ„Ÿ3æœ€å¤§å€¼           æ¨ªç”µæ„Ÿ4æ
             -œ€å¤§å€¼
   34              0x00,0x00,0x00    ,    0x00,0x00,0x00    ,    0x00,0x00,0x00    ,    0x00,0x00,0x00 ,
   35          //  æ¨ªç”µæ„Ÿ1æœ€å°å€¼          ç«–ç”µæ„Ÿ2æœ€å°å€¼            ç«–ç”µæ„Ÿ3æœ€å°å€¼           æ¨ªç”µæ„Ÿ4æ
             -œ€å°å€¼
   36              0x00,0x00,0x00    ,    0x00,0x00,0x00    ,    0x00,0x00,0x00    ,    0x00,0x00,0x00
   37          };
   38          //timeé‡‡é›†
   39          uint32 time_start;
   40          uint32 time_end;
   41          uint32 time_delta;
   42          
   43          //-------------------------------------------------------------------------------------------------------
             -------------
   44          // å‡½æ•°ç®€ä»‹     é€é£åŠ©æ‰‹ç¤ºæ³¢å™¨åˆå§‹åŒ–å‡½æ•°ï¼Œç”¨äºåˆå§‹åŒ–é€é£åŠ©æ‰‹å’Œæ— çº¿ä¸²å£è¾“å
             -‡º
   45          // å‚æ•°è¯´æ˜     void
   46          // è¿”å›å‚æ•°     void
   47          // ä½¿ç”¨ç¤ºä¾‹     seekfree_assistant_oscilloscope_init();
   48          //-------------------------------------------------------------------------------------------------------
C251 COMPILER V5.60.0,  command                                                            12/06/25  20:23:02  PAGE 2   

             -------------
   49          void seekfree_assistant_oscilloscope_init(void)
   50          {
   51   1          // é€é£åŠ©æ‰‹åˆå§‹åŒ–
   52   1        seekfree_assistant_init();
   53   1        // è®¾ç½®æ— çº¿ä¸²å£è¾“å‡º
   54   1        seekfree_assistant_interface_init(SEEKFREE_ASSISTANT_BLE6A20);
   55   1      }
   56          
   57          //-------------------------------------------------------------------------------------------------------
             -------------
   58          // å‡½æ•°ç®€ä»‹     é€é£åŠ©æ‰‹å‚æ•°è®¾ç½®å‡½æ•°ï¼Œç”¨äºè°ƒæ•´PIDå‚æ•°å’Œæ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
   59          // å‚æ•°è¯´æ˜     void
   60          // è¿”å›å‚æ•°     void
   61          // ä½¿ç”¨ç¤ºä¾‹     seekfree_assistant_set_parameter();
   62          //-------------------------------------------------------------------------------------------------------
             -------------
   63          void seekfree_assistant_set_parameter(void)
   64          {
   65   1          switch((int)seekfree_assistant_parameter[0])//æ ¹æ®é€šé“0çš„å€¼é€‰æ‹©è¦è°ƒçš„ç¯
   66   1          {
   67   2              case 0:
   68   2                  target_speed=seekfree_assistant_parameter[4];
   69   2                  target_angle=seekfree_assistant_parameter[5];
   70   2                  break;
   71   2              case 1://è§’åº¦ç¯
   72   2                  PID_angle_P=seekfree_assistant_parameter[1];
   73   2                  PID_angle_I=seekfree_assistant_parameter[2];
   74   2                  PID_angle_D=seekfree_assistant_parameter[3];
   75   2                  target_speed=seekfree_assistant_parameter[4];
   76   2                  target_angle=seekfree_assistant_parameter[5];
   77   2                  PID_angle.kp=PID_angle_P;
   78   2                  PID_angle.ki=PID_angle_I;
   79   2                  PID_angle.kd=PID_angle_D;
   80   2                  break;
   81   2              case 2://è§’é€Ÿåº¦ç¯
   82   2                  PID_angle_speed_P=seekfree_assistant_parameter[1];
   83   2                  PID_angle_speed_I=seekfree_assistant_parameter[2];
   84   2                  PID_angle_speed_D=seekfree_assistant_parameter[3];
   85   2                  target_speed=seekfree_assistant_parameter[4];
   86   2                  target_angle=seekfree_assistant_parameter[5];
   87   2                  PID_angle_speed.kp=PID_angle_speed_P;
   88   2                  PID_angle_speed.ki=PID_angle_speed_I;
   89   2                  PID_angle_speed.kd=PID_angle_speed_D;
   90   2                  break;
   91   2              case 3://å·¦è½®é€Ÿåº¦ç¯
   92   2                  PID_MOTOR_L_P=seekfree_assistant_parameter[1];
   93   2                  PID_MOTOR_L_I=seekfree_assistant_parameter[2];
   94   2                  PID_MOTOR_L_D=seekfree_assistant_parameter[3];
   95   2                  target_speed=seekfree_assistant_parameter[4];
   96   2                  target_angle=seekfree_assistant_parameter[5];
   97   2                  PID_MOTOR_L.kp=PID_MOTOR_L_P;
   98   2                  PID_MOTOR_L.ki=PID_MOTOR_L_I;
   99   2                  PID_MOTOR_L.kd=PID_MOTOR_L_D;
  100   2                  break;
  101   2              case 4://å³è½®é€Ÿåº¦ç¯
  102   2                  PID_MOTOR_R_P=seekfree_assistant_parameter[1];
  103   2                  PID_MOTOR_R_I=seekfree_assistant_parameter[2];
  104   2                  PID_MOTOR_R_D=seekfree_assistant_parameter[3];
  105   2                  target_speed=seekfree_assistant_parameter[4];
  106   2                  target_angle=seekfree_assistant_parameter[5];
  107   2                  PID_MOTOR_R.kp=PID_MOTOR_R_P;
  108   2                  PID_MOTOR_R.ki=PID_MOTOR_R_I;
  109   2                  PID_MOTOR_R.kd=PID_MOTOR_R_D;
  110   2                  break;
  111   2              case 5://ä¿å­˜å‚æ•°
C251 COMPILER V5.60.0,  command                                                            12/06/25  20:23:02  PAGE 3   

  112   2                  eeprom_write();
  113   2                  seekfree_assistant_parameter[0]=0;
  114   2                  break;
  115   2              default:
  116   2                  seekfree_assistant_parameter[0]=0;
  117   2                  break;
  118   2          }
  119   1          switch((int)seekfree_assistant_parameter[7])//é€šé“7é€‰æ‹©æ˜¾ç¤ºæ¨¡å¼
  120   1          {
  121   2              case 0:
  122   2                  uart_printf(UART_4, "angle: %f, speed: %f, motor_L: %f, motor_R: %f\r\n", target_angle, targe
             -t_speed, motor_output_L, motor_output_R);
  123   2                  break;
  124   2              case 1:
  125   2                  uart_printf(UART_4, "PID_angle_P: %f, PID_angle_I: %f, PID_angle_D: %f\r\n", PID_angle_P, PID
             -_angle_I, PID_angle_D);
  126   2                  break;
  127   2              case 2:
  128   2                  uart_printf(UART_4, "PID_angle_speed_P: %f, PID_angle_speed_I: %f, PID_angle_speed_D: %f\r\n"
             -, PID_angle_speed_P, PID_angle_speed_I, PID_angle_speed_D);
  129   2                  break;
  130   2              case 3:
  131   2                  uart_printf(UART_4, "PID_MOTOR_L_P: %f, PID_MOTOR_L_I: %f, PID_MOTOR_L_D: %f\r\n", PID_MOTOR_
             -L_P, PID_MOTOR_L_I, PID_MOTOR_L_D);
  132   2                  break;
  133   2              case 4:
  134   2                  uart_printf(UART_4, "PID_MOTOR_R_P: %f, PID_MOTOR_R_I: %f, PID_MOTOR_R_D: %f\r\n", PID_MOTOR_
             -R_P, PID_MOTOR_R_I, PID_MOTOR_R_D);
  135   2                  break;
  136   2              case 5://é€Ÿåº¦ç¯è°ƒè¯•ä¿®æ­£
  137   2                  uart_printf(UART_4, "encoder_data_dir_1: %d, encoder_data_dir_2: %d, motor_output_L: %f, moto
             -r_output_R: %f ,speed: %f\r\n"
  138   2                  , encoder_data_dir_1, encoder_data_dir_2, motor_output_L, motor_output_R, target_speed);
  139   2                  speed_debug();
  140   2                  break;
  141   2              case 6://è§’åº¦ç¯è°ƒè¯•ä¿®æ­£
  142   2                  uart_printf(UART_4, "encoder_data_dir_1: %d, encoder_data_dir_2: %d, motor_output_L: %f, moto
             -r_output_R: %f ,angle: %f, yaw: %f, angle_output: %f, angle_speed_output: %f\r\n"
  143   2                  , encoder_data_dir_1, encoder_data_dir_2, motor_output_L, motor_output_R, target_angle, euler
             -.yaw ,angle_output,angle_speed_output);
  144   2                  angle_debug();
  145   2                  break;
  146   2              case 7:
  147   2                  uart_printf(UART_4, "inductance_horizontal_1: %f, inductance_vertical_2: %f, inductance_verti
             -cal_3: %f, inductance_horizontal_4: %f\r\n"
  148   2                  , inductance_horizontal_1, inductance_vertical_2, inductance_vertical_3, inductance_horizonta
             -l_4);
  149   2                  core_trace();
  150   2                  break;
  151   2              default:
  152   2                  seekfree_assistant_parameter[7]=0;
  153   2                  break;
  154   2          }
  155   1      }
  156          
  157          //-------------------------------------------------------------------------------------------------------
             -------------
  158          // å‡½æ•°ç®€ä»‹     é€é£åŠ©æ‰‹ç¤ºæ³¢å™¨æ•°æ®åˆ†æå‡½æ•°ï¼Œç”¨äºå¤„ç†å’Œåˆ†æç¤ºæ³¢å™¨æ•°æ®
  159          // å‚æ•°è¯´æ˜     void
  160          // è¿”å›å‚æ•°     void
  161          // ä½¿ç”¨ç¤ºä¾‹     seekfree_assistant_oscilloscope_code();
  162          //-------------------------------------------------------------------------------------------------------
             -------------
  163          void seekfree_assistant_oscilloscope_code(void)
  164          {
  165   1        uint8 i;
C251 COMPILER V5.60.0,  command                                                            12/06/25  20:23:02  PAGE 4   

  166   1          if(!seekfree_flag)return;
  167   1          seekfree_assistant_data_analysis();
  168   1          // é€šè¿‡DEBUGä¸²å£è¾“å‡ºæ•°æ®
  169   1          printf("receive data : ");
  170   1          // é€šè¿‡DEBUGä¸²å£è¾“å‡ºå‚æ•°
  171   1          for(i = 0; i < SEEKFREE_ASSISTANT_SET_PARAMETR_COUNT; i++)
  172   1          {
  173   2              printf("%f ", seekfree_assistant_parameter[i]);
  174   2          }
  175   1          printf("\r\n");
  176   1          seekfree_assistant_set_parameter();
  177   1          // seekfree_assistant_oscilloscope_data.dat[0] = x;
  178   1          // seekfree_assistant_oscilloscope_data.dat[1] = y;
  179   1          // seekfree_assistant_oscilloscope_data.dat[2] = z;
  180   1          // seekfree_assistant_oscilloscope_data.dat[3] = w;
  181   1          // seekfree_assistant_oscilloscope_send(&seekfree_assistant_oscilloscope_data);
  182   1      }
  183          
  184          //ç¼–ç å™¨å‡½æ•°å®šä¹‰åŒº
  185          //-------------------------------------------------------------------------------------------------------
             -------------
  186          // å‡½æ•°ç®€ä»‹     PIT çš„å‘¨æœŸä¸­æ–­å¤„ç†å‡½æ•° è¿™ä¸ªå‡½æ•°å°†åœ¨ PIT å¯¹åº”çš„å®šæ—¶å™¨ä¸­æ–­è°ƒç”¨
             - è¯¦è§ isr.c
  187          // å‚æ•°è¯´æ˜     void
  188          // è¿”å›å‚æ•°     void
  189          // ä½¿ç”¨ç¤ºä¾‹     pit_handler();
  190          //-------------------------------------------------------------------------------------------------------
             -------------
  191          void pit_handler (void)
  192          {
  193   1          encoder_data_dir_1 = abs(encoder_get_count(ENCODER_DIR_1));                  // è·å–ç¼–ç å™¨è®¡æ•°
  194   1          encoder_data_dir_2 = abs(encoder_get_count(ENCODER_DIR_2));               // è·å–ç¼–ç å™¨è®¡æ•°
  195   1      
  196   1          encoder_clear_count(ENCODER_DIR_1);                                   // æ¸…ç©ºç¼–ç å™¨è®¡æ•°
  197   1          encoder_clear_count(ENCODER_DIR_2);                                 // æ¸…ç©ºç¼–ç å™¨è®¡æ•°
  198   1      }
  199          void encoder_init(void)
  200          {
  201   1          encoder_dir_init(ENCODER_DIR_1, ENCODER_DIR_DIR_1, ENCODER_DIR_PULSE_1);    // åˆå§‹åŒ–ç¼–ç å™¨æ¨¡å
             -—ä¸å¼•è„š å¸¦æ–¹å‘å¢é‡ç¼–ç å™¨æ¨¡å¼
  202   1          encoder_dir_init(ENCODER_DIR_2, ENCODER_DIR_DIR_2, ENCODER_DIR_PULSE_2);    // åˆå§‹åŒ–ç¼–ç å™¨æ¨¡å
             -—ä¸å¼•è„š å¸¦æ–¹å‘å¢é‡ç¼–ç å™¨æ¨¡å¼
  203   1                      // è®¾ç½®å®šæ—¶å™¨1ä¸­æ–­å›è°ƒå‡½æ•°
  204   1        tim1_irq_handler = pit_handler;
  205   1        
  206   1          pit_ms_init(PIT_CH, 100);                                                   // åˆå§‹åŒ– PIT ä¸ºå‘¨æœ
             -Ÿä¸­æ–­ 100ms å‘¨æœŸ
  207   1      }
  208          
  209          //-------------------------------------------------------------------------------------------------------
             -------------
  210          // å‡½æ•°ç®€ä»‹     ç¼–ç å™¨ç§¯åˆ†å‡½æ•°ï¼Œç”¨äºç´¯åŠ ç¼–ç å™¨è®¡æ•°å€¼
  211          // å‚æ•°è¯´æ˜     void
  212          // è¿”å›å‚æ•°     void
  213          // ä½¿ç”¨ç¤ºä¾‹     encoder_integrate();
  214          //-------------------------------------------------------------------------------------------------------
             -------------
  215          void encoder_integrate(void)
  216          {
  217   1          if(encoder_integral_flag){
  218   2          encoder_integral_1  += encoder_data_dir_1;
  219   2          encoder_integral_2  += encoder_data_dir_2;
  220   2          }
  221   1      }
  222          
  223          //-------------------------------------------------------------------------------------------------------
C251 COMPILER V5.60.0,  command                                                            12/06/25  20:23:02  PAGE 5   

             -------------
  224          // å‡½æ•°ç®€ä»‹     ç¼–ç å™¨æ•°æ®æ˜¾ç¤ºå‡½æ•°ï¼Œç”¨äºåœ¨IPSå±å¹•ä¸Šæ˜¾ç¤ºç¼–ç å™¨æ•°æ®
  225          // å‚æ•°è¯´æ˜     void
  226          // è¿”å›å‚æ•°     void
  227          // ä½¿ç”¨ç¤ºä¾‹     encoder_text();
  228          //-------------------------------------------------------------------------------------------------------
             -------------
  229          void encoder_text(void)
  230          {
  231   1          sprintf(txt, "encoder1: %5d", encoder_data_dir_1);
  232   1          ips200_show_string(0,0,txt);
  233   1          sprintf(txt, "encoder2: %5d", encoder_data_dir_2);
  234   1          ips200_show_string(0,16,txt);
  235   1      }
  236          
  237          //èœ‚é¸£å™¨å‡½æ•°å®šä¹‰åŒº
  238          //-------------------------------------------------------------------------------------------------------
             -------------
  239          // å‡½æ•°ç®€ä»‹     èœ‚é¸£å™¨æ§åˆ¶å‡½æ•°ï¼Œç”¨äºæ§åˆ¶èœ‚é¸£å™¨å‘å£°æ—¶é—´
  240          // å‚æ•°è¯´æ˜     time: èœ‚é¸£å™¨å‘å£°æ—¶é—´(ms)
  241          // è¿”å›å‚æ•°     void
  242          // ä½¿ç”¨ç¤ºä¾‹     buzzer_time(100);
  243          //-------------------------------------------------------------------------------------------------------
             -------------
  244          void buzzer_time(uint16 time)
  245          {
  246   1          gpio_set_level(IO_P07, 1);
  247   1          system_delay_ms(time);
  248   1          gpio_set_level(IO_P07, 0);
  249   1          system_delay_ms(time);
  250   1      }
  251          
  252          //éœå°”å‡½æ•°å®šä¹‰åŒº
  253          //-------------------------------------------------------------------------------------------------------
             -------------
  254          // å‡½æ•°ç®€ä»‹     éœå°”ä¼ æ„Ÿå™¨åˆå§‹åŒ–å‡½æ•°ï¼Œç”¨äºåˆå§‹åŒ–éœå°”ä¼ æ„Ÿå™¨å¼•è„š
  255          // å‚æ•°è¯´æ˜     void
  256          // è¿”å›å‚æ•°     void
  257          // ä½¿ç”¨ç¤ºä¾‹     hall_init();
  258          //-------------------------------------------------------------------------------------------------------
             -------------
  259          void hall_init(void)
  260          {
  261   1          gpio_init(HALL_PIN, GPI, GPIO_HIGH, GPI_PULL_UP);
  262   1      }
  263          
  264          //-------------------------------------------------------------------------------------------------------
             -------------
  265          // å‡½æ•°ç®€ä»‹     éœå°”ä¼ æ„Ÿå™¨æ•°æ®æ˜¾ç¤ºå‡½æ•°ï¼Œç”¨äºåœ¨IPSå±å¹•ä¸Šæ˜¾ç¤ºéœå°”ä¼ æ„Ÿå™¨çŠ¶æ€
  266          // å‚æ•°è¯´æ˜     void
  267          // è¿”å›å‚æ•°     void
  268          // ä½¿ç”¨ç¤ºä¾‹     hall_text();
  269          //-------------------------------------------------------------------------------------------------------
             -------------
  270          void hall_text(void)
  271          {
  272   1          sprintf(txt, "hall: %d", gpio_get_level(HALL_PIN));
  273   1          ips200_show_string(0,0,txt);
  274   1      }   
  275          
  276          //ADCå‡½æ•°å®šä¹‰åŒº
  277          //-------------------------------------------------------------------------------------------------------
             -------------
  278          // å‡½æ•°ç®€ä»‹     ADCåˆå§‹åŒ–å‡½æ•°ï¼Œç”¨äºåˆå§‹åŒ–æ‰€æœ‰ADCé€šé“
  279          // å‚æ•°è¯´æ˜     void
  280          // è¿”å›å‚æ•°     void
C251 COMPILER V5.60.0,  command                                                            12/06/25  20:23:02  PAGE 6   

  281          // ä½¿ç”¨ç¤ºä¾‹     adc_main_init();
  282          //-------------------------------------------------------------------------------------------------------
             -------------
  283          void adc_main_init(void)
  284          {
  285   1          adc_init(ADC_CHANNEL1, ADC_12BIT);                                          // åˆå§‹åŒ–å¯¹åº” ADC é€
             -šé“ä¸ºå¯¹åº”ç²¾åº¦
  286   1          adc_init(ADC_CHANNEL2, ADC_12BIT);                                          // åˆå§‹åŒ–å¯¹åº” ADC é€
             -šé“ä¸ºå¯¹åº”ç²¾åº¦
  287   1          adc_init(ADC_CHANNEL3, ADC_12BIT);                                          // åˆå§‹åŒ–å¯¹åº” ADC é€
             -šé“ä¸ºå¯¹åº”ç²¾åº¦
  288   1          adc_init(ADC_CHANNEL4, ADC_12BIT);                                           // åˆå§‹åŒ–å¯¹åº” ADC é
             -€šé“ä¸ºå¯¹åº”ç²¾åº¦
  289   1          adc_init(ADC_CHANNEL5, ADC_12BIT);                                           // åˆå§‹åŒ–å¯¹åº” ADC é
             -€šé“ä¸ºå¯¹åº”ç²¾åº¦
  290   1          adc_init(ADC_CHANNEL6, ADC_12BIT);                                           // åˆå§‹åŒ–å¯¹åº” ADC é
             -€šé“ä¸ºå¯¹åº”ç²¾åº¦
  291   1      }
  292          
  293          //-------------------------------------------------------------------------------------------------------
             -------------
  294          // å‡½æ•°ç®€ä»‹     ADCæ•°æ®è¯»å–å‡½æ•°ï¼Œç”¨äºè¯»å–æ‰€æœ‰ç”µæ„Ÿå€¼å’Œç”µå‹å€¼
  295          // å‚æ•°è¯´æ˜     void
  296          // è¿”å›å‚æ•°     void
  297          // ä½¿ç”¨ç¤ºä¾‹     adc_main_read();
  298          //-------------------------------------------------------------------------------------------------------
             -------------
  299          void adc_main_read(void)
  300          {
  301   1          inductance_horizontal_1= (float)adc_convert(ADC_CHANNEL1);
  302   1          inductance_vertical_2= (float)adc_convert(ADC_CHANNEL2);
  303   1          inductance_horizontal_middle =(float)adc_convert(ADC_CHANNEL6);
  304   1          inductance_vertical_3= (float)adc_convert(ADC_CHANNEL3);
  305   1          inductance_horizontal_4= (float)adc_convert(ADC_CHANNEL4);
  306   1          vcc= (float)adc_convert(ADC_CHANNEL5);  
  307   1          // seekfree_assistant_oscilloscope_code(adc1,adc2,adc3,adc4);
  308   1      }
  309          
  310          //-------------------------------------------------------------------------------------------------------
             -------------
  311          // å‡½æ•°ç®€ä»‹     ADCæ•°æ®æ˜¾ç¤ºå‡½æ•°ï¼Œç”¨äºåœ¨IPSå±å¹•ä¸Šæ˜¾ç¤ºADCæ•°æ®
  312          // å‚æ•°è¯´æ˜     void
  313          // è¿”å›å‚æ•°     void
  314          // ä½¿ç”¨ç¤ºä¾‹     adc_text();
  315          //-------------------------------------------------------------------------------------------------------
             -------------
  316          void adc_text(void)
  317          {
  318   1          sprintf(txt, "inductance_horizontal_1: %08.2f", inductance_horizontal_1);
  319   1          ips200_show_string(0,0,txt);
  320   1          sprintf(txt, "inductance_vertical_2: %08.2f", inductance_vertical_2);
  321   1          ips200_show_string(0,16,txt);
  322   1          sprintf(txt, "inductance_vertical_3: %08.2f", inductance_vertical_3);
  323   1          ips200_show_string(0,32,txt);
  324   1          sprintf(txt, "inductance_horizontal_4: %08.2f", inductance_horizontal_4);
  325   1          ips200_show_string(0,48,txt);
  326   1          sprintf(txt, "inductance_horizontal_m: %08.2f", inductance_horizontal_middle);
  327   1          ips200_show_string(0,64,txt); 
  328   1          sprintf(txt, "horizontal_diff_ratio_sum: %.2f", horizontal_diff_ratio_sum);
  329   1          ips200_show_string(0,80,txt);
  330   1          sprintf(txt, "vertical_diff_ratio_sum: %.2f", vertical_diff_ratio_sum);
  331   1          ips200_show_string(0,96,txt);
  332   1      }
  333          
  334          //IPS200å‡½æ•°å®šä¹‰åŒº
  335          //-------------------------------------------------------------------------------------------------------
C251 COMPILER V5.60.0,  command                                                            12/06/25  20:23:02  PAGE 7   

             -------------
  336          // å‡½æ•°ç®€ä»‹     IPSæ˜¾ç¤ºæµ‹è¯•å‡½æ•°ï¼Œç”¨äºæµ‹è¯•IPSæ˜¾ç¤ºåŠŸèƒ½
  337          // å‚æ•°è¯´æ˜     void
  338          // è¿”å›å‚æ•°     void
  339          // ä½¿ç”¨ç¤ºä¾‹     ips_text();
  340          //-------------------------------------------------------------------------------------------------------
             -------------
  341          void ips_text(void)
  342          {
  343   1        ips200_show_string(0,0,"HI,this is a test");
  344   1      }
  345          
  346          //-------------------------------------------------------------------------------------------------------
             -------------
  347          // å‡½æ•°ç®€ä»‹     ä¸²å£æ‰“å°å‡½æ•°ï¼Œç”¨äºé€šè¿‡ä¸²å£è¾“å‡ºæ ¼å¼åŒ–å­—ç¬¦ä¸²
  348          // å‚æ•°è¯´æ˜     uart_n: ä¸²å£ç¼–å·
  349          //              format: æ ¼å¼åŒ–å­—ç¬¦ä¸²
  350          //              ...: å¯å˜å‚æ•°åˆ—è¡¨
  351          // è¿”å›å‚æ•°     void
  352          // ä½¿ç”¨ç¤ºä¾‹     uart_printf(UART_4, "test: %d", 123);
  353          //-------------------------------------------------------------------------------------------------------
             -------------
  354          void uart_printf(uart_index_enum uart_n,const char* format,...)
  355          {
  356   1        char buffer[256];
  357   1        va_list args;
  358   1        va_start(args,format);
  359   1        vsprintf(buffer,format,args);
  360   1        uart_write_string (uart_n, buffer);
  361   1        va_end(args);
  362   1      }
  363          
  364          //-------------------------------------------------------------------------------------------------------
             -------------
  365          // å‡½æ•°ç®€ä»‹     ä¸²å£æ‰“å°æµ‹è¯•å‡½æ•°ï¼Œç”¨äºæµ‹è¯•ä¸²å£é€šä¿¡åŠŸèƒ½
  366          // å‚æ•°è¯´æ˜     void
  367          // è¿”å›å‚æ•°     void
  368          // ä½¿ç”¨ç¤ºä¾‹     uart_printf_test();
  369          //-------------------------------------------------------------------------------------------------------
             -------------
  370          void uart_printf_test(void)
  371          {
  372   1          uint8 data_len = 0;
  373   1          uart_printf(UART_4, "test, %d\n", 123);
  374   1          data_len = ble6a20_read_buffer(txt, 16);
  375   1          if(data_len > 0)
  376   1          {   
  377   2              uart_printf(UART_4, "data_len: %d\n", data_len);
  378   2              uart_printf(UART_4, "recv txt: %s\n", txt);
  379   2          }
  380   1          system_delay_ms(100);
  381   1      }
  382          
  383          //-------------------------------------------------------------------------------------------------------
             -------------
  384          // å‡½æ•°ç®€ä»‹     ç”µå‹æ˜¾ç¤ºå‡½æ•°ï¼Œç”¨äºåœ¨å±å¹•ä¸Šæ˜¾ç¤ºå½“å‰ç”µå‹å€¼
  385          // å‚æ•°è¯´æ˜     void
  386          // è¿”å›å‚æ•°     void
  387          // ä½¿ç”¨ç¤ºä¾‹     display_vcc();
  388          //-------------------------------------------------------------------------------------------------------
             -------------
  389          void display_vcc(void) {
  390   1          // æ ¼å¼åŒ–ç”µå‹å­—ç¬¦ä¸²
  391   1          vcc= adc_convert(ADC_CHANNEL5)/10.491;
  392   1      #if VCC_ALARM_FLAG
                   if(vcc<11.1&&vcc>1.5){
C251 COMPILER V5.60.0,  command                                                            12/06/25  20:23:02  PAGE 8   

                       buzzer_time(100);
                   }
               #endif  
  397   1          sprintf(txt, "VCC: %.2fV", vcc) ;
  398   1          // åœ¨å±å¹•å³ä¸Šè§’æ˜¾ç¤ºVCCå€¼
  399   1          ips200_show_string(150, 10, txt);
  400   1      }
  401          //-------------------------------------------------------------------------------------------------------
             -------------
  402          // å‡½æ•°ç®€ä»‹     ç”µæ„Ÿå€¼å†™å…¥EEPROMå‡½æ•°ï¼Œç”¨äºå­˜å‚¨ç”µæ„Ÿçš„æœ€å¤§æœ€å°å€¼
  403          // å‚æ•°è¯´æ˜     void
  404          // è¿”å›å‚æ•°     void
  405          // ä½¿ç”¨ç¤ºä¾‹     eeprom_write_inductance_max_min();
  406          //-------------------------------------------------------------------------------------------------------
             -------------
  407          void eeprom_write_inductance_max_min(void)
  408          {
  409   1          uint32 hex_value;
  410   1      
  411   1          hex_value = (uint32)inductance_horizontal_1_max;
  412   1          inductance_max_min[0] = (uint8)(hex_value >> 16);
  413   1          inductance_max_min[1] = (uint8)(hex_value >> 8);
  414   1          inductance_max_min[2] = (uint8)(hex_value);
  415   1      
  416   1          hex_value = (uint32)inductance_vertical_2_max;
  417   1          inductance_max_min[3] = (uint8)(hex_value >> 16);
  418   1          inductance_max_min[4] = (uint8)(hex_value >> 8);
  419   1          inductance_max_min[5] = (uint8)(hex_value);
  420   1          
  421   1          hex_value = (uint32)inductance_vertical_3_max;
  422   1          inductance_max_min[6] = (uint8)(hex_value >> 16);
  423   1          inductance_max_min[7] = (uint8)(hex_value >> 8);
  424   1          inductance_max_min[8] = (uint8)(hex_value);
  425   1          
  426   1          hex_value = (uint32)inductance_horizontal_4_max;
  427   1          inductance_max_min[9] = (uint8)(hex_value >> 16);
  428   1          inductance_max_min[10] = (uint8)(hex_value >> 8);
  429   1          inductance_max_min[11] = (uint8)(hex_value);
  430   1          
  431   1          // å­˜å‚¨æœ€å°å€¼
  432   1          hex_value = (uint32)inductance_horizontal_1_min;
  433   1          inductance_max_min[12] = (uint8)(hex_value >> 16);
  434   1          inductance_max_min[13] = (uint8)(hex_value >> 8);
  435   1          inductance_max_min[14] = (uint8)(hex_value);
  436   1          
  437   1          hex_value = (uint32)inductance_vertical_2_min;
  438   1          inductance_max_min[15] = (uint8)(hex_value >> 16);
  439   1          inductance_max_min[16] = (uint8)(hex_value >> 8);
  440   1          inductance_max_min[17] = (uint8)(hex_value);
  441   1          
  442   1          hex_value = (uint32)inductance_vertical_3_min;
  443   1          inductance_max_min[18] = (uint8)(hex_value >> 16);
  444   1          inductance_max_min[19] = (uint8)(hex_value >> 8);
  445   1          inductance_max_min[20] = (uint8)(hex_value);
  446   1          
  447   1          hex_value = (uint32)inductance_horizontal_4_min;
  448   1          inductance_max_min[21] = (uint8)(hex_value >> 16);
  449   1          inductance_max_min[22] = (uint8)(hex_value >> 8);
  450   1          inductance_max_min[23] = (uint8)(hex_value);
  451   1          // å†™å…¥EEPROMï¼ˆä»åœ°å€eepromåå¼€å§‹ï¼Œé¿å¼€PIDå‚æ•°åŒºåŸŸï¼‰
  452   1          iap_write_buff(sizeof(eeprom_PID)+1, inductance_max_min, sizeof(inductance_max_min));
  453   1      }
  454          
  455          //EEPROMå†™å…¥å‡½æ•°å®šä¹‰åŒº
  456          //-------------------------------------------------------------------------------------------------------
             -------------
C251 COMPILER V5.60.0,  command                                                            12/06/25  20:23:02  PAGE 9   

  457          // å‡½æ•°ç®€ä»‹     EEPROMå†™å…¥å‡½æ•°ï¼Œç”¨äºå°†PIDå‚æ•°å†™å…¥EEPROM
  458          // å‚æ•°è¯´æ˜     void
  459          // è¿”å›å‚æ•°     void
  460          // ä½¿ç”¨ç¤ºä¾‹     eeprom_write();
  461          //-------------------------------------------------------------------------------------------------------
             -------------
  462          void eeprom_write(void)
  463          {
  464   1          uint8 i;
  465   1          float temp_value;
  466   1          uint32 hex_value;
  467   1          
  468   1          // å¾ªç¯å­˜å‚¨æ‰€æœ‰15ä¸ªPIDå‚æ•°ï¼ˆ5ç»„ï¼Œæ¯ç»„3ä¸ªå‚æ•°ï¼‰
  469   1          for(i = 0; i < 15; i++) {
  470   2              // æ ¹æ®ç´¢å¼•é€‰æ‹©å¯¹åº”çš„PIDå‚æ•°
  471   2              if(i == 0) temp_value = PID_angle_P;
  472   2              else if(i == 1) temp_value = PID_angle_I;
  473   2              else if(i == 2) temp_value = PID_angle_D;
  474   2              else if(i == 3) temp_value = PID_angle_speed_P;
  475   2              else if(i == 4) temp_value = PID_angle_speed_I;
  476   2              else if(i == 5) temp_value = PID_angle_speed_D;
  477   2              else if(i == 6) temp_value = PID_MOTOR_L_P;
  478   2              else if(i == 7) temp_value = PID_MOTOR_L_I;
  479   2              else if(i == 8) temp_value = PID_MOTOR_L_D;
  480   2              else if(i == 9) temp_value = PID_MOTOR_R_P;
  481   2              else if(i == 10) temp_value = PID_MOTOR_R_I;
  482   2              else if(i == 11) temp_value = PID_MOTOR_R_D;
  483   2              // é¢„ç•™3ä¸ªå‚æ•°ä½ç½®ä¾›æœªæ¥æ‰©å±•
  484   2              else if(i == 12) temp_value = 0.0f;
  485   2              else if(i == 13) temp_value = 0.0f;
  486   2              else if(i == 14) temp_value = 0.0f;
  487   2              
  488   2              // å°†æµ®ç‚¹æ•°è½¬æ¢ä¸º32ä½æ•´æ•°ï¼ˆä¿ç•™4ä½å°æ•°ç²¾åº¦ï¼‰
  489   2              hex_value = (uint32)(temp_value * 100000.0f);
  490   2              
  491   2              // å­˜å‚¨åˆ°EEPROMæ•°ç»„ï¼ˆæ¯ä¸ªå‚æ•°å ç”¨4å­—èŠ‚ï¼‰
  492   2              eeprom_PID[i*3] = (uint8)(hex_value >> 16);        // æœ€é«˜å­—èŠ‚
  493   2              eeprom_PID[i*3+1] = (uint8)(hex_value >> 8);       // æ¬¡ä½å­—èŠ‚
  494   2              eeprom_PID[i*3+2] = (uint8)(hex_value);            // æœ€ä½å­—èŠ‚
  495   2          }
  496   1          eeprom_PID[45] = 0x00; // å¯åŠ¨è®¡æ•°ï¼Œä½ç½®å˜ä¸º45 (15*3)
  497   1      
  498   1          // å†™å…¥æ‰€æœ‰PIDå‚æ•°
  499   1          iap_write_buff(0, eeprom_PID, sizeof(eeprom_PID));
  500   1      }
  501          
  502          
  503          //è¯»å–ç”µæ„Ÿæœ€å¤§å€¼æœ€å°å€¼
  504          //-------------------------------------------------------------------------------------------------------
             -------------
  505          // å‡½æ•°ç®€ä»‹     ç”µæ„Ÿå€¼è¯»å–å‡½æ•°ï¼Œç”¨äºä»EEPROMè¯»å–ç”µæ„Ÿçš„æœ€å¤§æœ€å°å€¼
  506          // å‚æ•°è¯´æ˜     void
  507          // è¿”å›å‚æ•°     void
  508          // ä½¿ç”¨ç¤ºä¾‹     eeprom_read_inductance_max_min();
  509          //-------------------------------------------------------------------------------------------------------
             -------------
  510          void eeprom_read_inductance_max_min(void)
  511          {
  512   1          uint32 hex_value;
  513   1          
  514   1          // ä»EEPROMè¯»å–æ•°æ®ï¼ˆä»åœ°å€ sizeof(eeprom_PID)+1 å¼€å§‹ï¼‰
  515   1          iap_read_buff(sizeof(eeprom_PID)+1, inductance_max_min, sizeof(inductance_max_min));
  516   1          
  517   1          // è¯»å–å¹¶è½¬æ¢æœ€å¤§å€¼
  518   1          hex_value = ((uint32)inductance_max_min[0] << 16) |
  519   1                      ((uint32)inductance_max_min[1] << 8) |
C251 COMPILER V5.60.0,  command                                                            12/06/25  20:23:02  PAGE 10  

  520   1                      ((uint32)inductance_max_min[2]);
  521   1          inductance_horizontal_1_max = (float)hex_value;
  522   1          
  523   1          hex_value = ((uint32)inductance_max_min[3] << 16) |
  524   1                      ((uint32)inductance_max_min[4] << 8) |
  525   1                      ((uint32)inductance_max_min[5]);
  526   1          inductance_vertical_2_max = (float)hex_value;
  527   1          
  528   1          hex_value = ((uint32)inductance_max_min[6] << 16) |
  529   1                      ((uint32)inductance_max_min[7] << 8) |
  530   1                      ((uint32)inductance_max_min[8]);
  531   1          inductance_vertical_3_max = (float)hex_value;
  532   1          
  533   1          hex_value = ((uint32)inductance_max_min[9] << 16) |
  534   1                      ((uint32)inductance_max_min[10] << 8) |
  535   1                      ((uint32)inductance_max_min[11]);
  536   1          inductance_horizontal_4_max = (float)hex_value;
  537   1          
  538   1          // è¯»å–å¹¶è½¬æ¢æœ€å°å€¼
  539   1          hex_value = ((uint32)inductance_max_min[12] << 16) |
  540   1                      ((uint32)inductance_max_min[13] << 8) |
  541   1                      ((uint32)inductance_max_min[14]);
  542   1          inductance_horizontal_1_min = (float)hex_value;
  543   1          
  544   1          hex_value = ((uint32)inductance_max_min[15] << 16) |
  545   1                      ((uint32)inductance_max_min[16] << 8) |
  546   1                      ((uint32)inductance_max_min[17]);
  547   1          inductance_vertical_2_min = (float)hex_value;
  548   1          
  549   1          hex_value = ((uint32)inductance_max_min[18] << 16) |
  550   1                      ((uint32)inductance_max_min[19] << 8) |
  551   1                      ((uint32)inductance_max_min[20]);
  552   1          inductance_vertical_3_min = (float)hex_value;
  553   1          
  554   1          hex_value = ((uint32)inductance_max_min[21] << 16) |
  555   1                      ((uint32)inductance_max_min[22] << 8) |
  556   1                      ((uint32)inductance_max_min[23]);
  557   1          inductance_horizontal_4_min = (float)hex_value;
  558   1      }
  559          
  560          //æ“¦é™¤eepromç¼“å†²åŒº
  561          //-------------------------------------------------------------------------------------------------------
             -------------
  562          // å‡½æ•°ç®€ä»‹     EEPROMæ“¦é™¤å‡½æ•°ï¼Œç”¨äºæ¸…é™¤EEPROMä¸­çš„æ•°æ®
  563          // å‚æ•°è¯´æ˜     void
  564          // è¿”å›å‚æ•°     void
  565          // ä½¿ç”¨ç¤ºä¾‹     eeprom_erase();
  566          //-------------------------------------------------------------------------------------------------------
             -------------
  567          void eeprom_erase(void)
  568          {
  569   1          // uint8 i;
  570   1          iap_erase_page(200);
  571   1          // // æ“¦é™¤PIDå‚æ•°åŒºåŸŸ
  572   1          // for(i = 0; i < 45; i++) {
  573   1          //     eeprom_PID[i] = 0x00;
  574   1          // }
  575   1          // eeprom_PID[45] = 0x00; // å¯åŠ¨è®¡æ•°
  576   1          
  577   1          // // æ“¦é™¤ç”µæ„Ÿå€¼åŒºåŸŸ
  578   1          // for(i = 0; i < 24; i++) {
  579   1          //     inductance_max_min[i] = 0x00;
  580   1          // }
  581   1          
  582   1          // å†™å…¥æ“¦é™¤åçš„æ•°æ®
  583   1          // iap_write_buff(0, eeprom_PID, sizeof(eeprom_PID));
C251 COMPILER V5.60.0,  command                                                            12/06/25  20:23:02  PAGE 11  

  584   1          // iap_write_buff(sizeof(eeprom_PID)+1, inductance_max_min, sizeof(inductance_max_min));
  585   1      }
  586          
  587          //-------------------------------------------------------------------------------------------------------
             -------------
  588          // å‡½æ•°ç®€ä»‹     EEPROMåˆå§‹åŒ–å‡½æ•°ï¼Œç”¨äºåˆå§‹åŒ–EEPROMå¹¶è¯»å–å­˜å‚¨çš„å‚æ•°
  589          // å‚æ•°è¯´æ˜     void
  590          // è¿”å›å‚æ•°     void
  591          // ä½¿ç”¨ç¤ºä¾‹     eeprom_init_code();
  592          //-------------------------------------------------------------------------------------------------------
             -------------
  593          void eeprom_init_code(void)
  594          {
  595   1          uint8 i;
  596   1          float temp_value;
  597   1          uint32 hex_value;
  598   1          
  599   1          iap_init();
  600   1          iap_read_buff(0x00, eeprom_PID, sizeof(eeprom_PID));//è¯»å–eeprom_PID
  601   1          if(eeprom_PID[45] != 0x00)
  602   1          {
  603   2                  // æ“¦é™¤EEPROMé¡µ
  604   2              iap_erase_page(200);
  605   2              eeprom_write();
  606   2              eeprom_write_inductance_max_min(); // å†™å…¥ç”µæ„Ÿå€¼
  607   2              iap_read_buff(0x00, eeprom_PID, sizeof(eeprom_PID));//è¯»å–eeprom_PID
  608   2      
  609   2              
  610   2          }
  611   1                      // è¯»å–ç”µæ„Ÿå€¼
  612   1          eeprom_read_inductance_max_min();
  613   1      
  614   1          
  615   1          // å¾ªç¯å°†EEPROMä¸­çš„æ•°æ®è½¬æ¢å›PIDå‚æ•°
  616   1          for(i = 0; i < 15; i++) {
  617   2              // ä»EEPROMä¸­è¯»å–32ä½æ•´æ•°
  618   2              hex_value = ((uint32)eeprom_PID[i*3] << 16) |
  619   2                         ((uint32)eeprom_PID[i*3+1] << 8) |
  620   2                         ((uint32)eeprom_PID[i*3+2]);
  621   2              
  622   2              // è½¬æ¢å›æµ®ç‚¹æ•°ï¼ˆé™¤ä»¥100000å¾—åˆ°åŸå§‹å€¼ï¼‰
  623   2              temp_value = (float)hex_value / 100000.0f;
  624   2              
  625   2              // æ ¹æ®ç´¢å¼•å°†å€¼èµ‹ç»™å¯¹åº”çš„PIDå‚æ•°
  626   2              if(i == 0) PID_angle_P = temp_value;
  627   2              else if(i == 1) PID_angle_I = temp_value;
  628   2              else if(i == 2) PID_angle_D = temp_value;
  629   2              else if(i == 3) PID_angle_speed_P = temp_value;
  630   2              else if(i == 4) PID_angle_speed_I = temp_value;
  631   2              else if(i == 5) PID_angle_speed_D = temp_value;
  632   2              else if(i == 6) PID_MOTOR_L_P = temp_value;
  633   2              else if(i == 7) PID_MOTOR_L_I = temp_value;
  634   2              else if(i == 8) PID_MOTOR_L_D = temp_value;
  635   2              else if(i == 9) PID_MOTOR_R_P = temp_value;
  636   2              else if(i == 10) PID_MOTOR_R_I = temp_value;
  637   2              else if(i == 11) PID_MOTOR_R_D = temp_value;
  638   2              // å…¶ä½™å‚æ•°æš‚ä¸å¤„ç†
  639   2          }
  640   1      }
  641          
  642          //åˆå§‹åŒ–å‡½æ•°å®šä¹‰åŒº
  643          //-------------------------------------------------------------------------------------------------------
             -------------
  644          // å‡½æ•°ç®€ä»‹     ç³»ç»Ÿåˆå§‹åŒ–å‡½æ•°ï¼Œç”¨äºåˆå§‹åŒ–æ‰€æœ‰å¤–è®¾å’Œç³»ç»Ÿå‚æ•°
  645          // å‚æ•°è¯´æ˜     void
  646          // è¿”å›å‚æ•°     void
C251 COMPILER V5.60.0,  command                                                            12/06/25  20:23:02  PAGE 12  

  647          // ä½¿ç”¨ç¤ºä¾‹     to_init();
  648          //-------------------------------------------------------------------------------------------------------
             -------------
  649          void to_init(void)
  650          {
  651   1          ips200_init();
  652   1          key_into();                             // åˆå§‹åŒ–æŒ‰é”®
  653   1          encoder_init();
  654   1          menu_init();                           // åˆå§‹åŒ–èœå•ç³»ç»Ÿ
  655   1          menu_display();                        // é¦–æ¬¡æ˜¾ç¤ºèœå•   
  656   1          gpio_init(IO_P07, GPO, 0, GPO_PUSH_PULL);//åˆå§‹åŒ–èœ‚é¸£å™¨
  657   1          gpio_init(HALL_PIN, GPI, GPIO_HIGH, GPI_PULL_UP);;//åˆå§‹åŒ–éœå°”ä¼ æ„Ÿå™¨
  658   1          adc_main_init();//åˆå§‹åŒ–ADC
  659   1          while(ble6a20_init())
  660   1          {
  661   2              system_delay_ms(100);
  662   2              printf("wifi init error\n");
  663   2          }
  664   1          imu660ra_init();
  665   1          quaternion_init(); // åˆå§‹åŒ–å››å…ƒæ•°
  666   1          gyro_calibrate(200);
  667   1          //åˆå§‹åŒ–é€é£åŠ©æ‰‹
  668   1          seekfree_assistant_oscilloscope_init();
  669   1          //åˆå§‹åŒ–eeprom
  670   1          eeprom_init_code();
  671   1          //åˆå§‹åŒ–ä¸²å£
  672   1          ble6a20_init();
  673   1          PidInit();
  674   1          control_init();
  675   1          //åˆå§‹åŒ–ä»»åŠ¡
  676   1      
  677   1          pit_ms_init(TIM4_PIT, 1);
  678   1          tim4_irq_handler=set_task_mode;
  679   1          pit_ms_init(TIM11_PIT, 5);
  680   1          tim11_irq_handler=imu_isr;
  681   1      
  682   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      5664     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       499     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =      1145     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
