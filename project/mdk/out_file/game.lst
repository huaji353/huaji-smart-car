C251 COMPILER V5.60.0,  game                                                               15/04/25  11:56:12  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE game
OBJECT MODULE PLACED IN .\out_file\game.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE ..\code\game.c LARGE NOALIAS WARNINGLEVEL(3) OPTIMIZE(0,SIZE) BROWSE I
                    -NCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver;..\use
                    -r;..\code) DEBUG PRINT(.\out_file\game.lst) TABS(2) OBJECT(.\out_file\game.obj) 

stmt  level    source

    1          #include "zf_common_headfile.h"
    2          #include "game.h"
    3          
    4          /********************************************************************************************************
             -*************
    5          * 游戏对象类型
    6          *********************************************************************************************************
             -************/
    7          #define GAME_OBJ_PLAYER        0
    8          #define GAME_OBJ_ENEMY         1
    9          #define GAME_OBJ_BULLET        2
   10          
   11          /********************************************************************************************************
             -*************
   12          * 屏幕参数 - 横屏模式
   13          *********************************************************************************************************
             -************/
   14          #define SCREEN_WIDTH           320     // 横屏宽度
   15          #define SCREEN_HEIGHT          240     // 横屏高度
   16          #define GAME_AREA_LEFT         20      // 游戏区域左侧位置
   17          
   18          /********************************************************************************************************
             -*************
   19          * 游戏配置参数
   20          *********************************************************************************************************
             -************/
   21          #define MAX_OBJECTS            15
   22          #define PLAYER_SPEED           5       // 玩家速度
   23          #define ENEMY_SPEED            3       // 敌人速度
   24          #define BULLET_SPEED           7       // 子弹速度
   25          #define ENEMY_SPAWN_RATE       15      // 敌人生成率(百分比)
   26          #define SCORE_PER_ENEMY        10      // 每个敌人得分
   27          
   28          /********************************************************************************************************
             -*************
   29          * 对象尺寸
   30          *********************************************************************************************************
             -************/
   31          #define PLAYER_WIDTH           14
   32          #define PLAYER_HEIGHT          10
   33          #define ENEMY_WIDTH            10
   34          #define ENEMY_HEIGHT           8
   35          #define BULLET_WIDTH           5
   36          #define BULLET_HEIGHT          2
   37          
   38          /********************************************************************************************************
             -*************
   39          * 颜色定义
   40          *********************************************************************************************************
             -************/
   41          #define COLOR_PLAYER           RGB565_RED
   42          #define COLOR_ENEMY            RGB565_BLUE
   43          #define COLOR_BULLET           RGB565_YELLOW
   44          #define COLOR_BG               RGB565_WHITE
   45          #define COLOR_TEXT             RGB565_BLACK
   46          
   47          /********************************************************************************************************
C251 COMPILER V5.60.0,  game                                                               15/04/25  11:56:12  PAGE 2   

             -*************
   48          * 玩家区域清除参数
   49          *********************************************************************************************************
             -************/
   50          #define PLAYER_CLEAR_MARGIN    10       // Reasonable margin around player for clearing
   51          #define BORDER_CLEAR_WIDTH     (ENEMY_WIDTH + ENEMY_SPEED + 2) // Width of the strip to clear at the left
             - border
   52          
   53          /********************************************************************************************************
             -*************
   54          * 游戏对象结构体
   55          *********************************************************************************************************
             -************/
   56          typedef struct 
   57          {
   58              int16 x;                  // 坐标X
   59              int16 y;                  // 坐标Y
   60              int16 old_x;              // 旧坐标X，用于局部擦除
   61              int16 old_y;              // 旧坐标Y，用于局部擦除
   62              uint8 type;               // 类型
   63              uint8 width;              // 宽度
   64              uint8 height;             // 高度
   65              uint8 active;             // 是否激活
   66              uint8 moved;              // 是否移动过
   67          } game_object_t;
   68          
   69          /********************************************************************************************************
             -*************
   70          * 游戏状态
   71          *********************************************************************************************************
             -************/
   72          typedef struct 
   73          {
   74              game_object_t objects[MAX_OBJECTS];   // 游戏对象数组
   75              uint8 obj_count;                      // 对象数量
   76              uint16 score;                         // 得分
   77              uint8 game_over;                      // 游戏结束标志
   78          } game_state_t;
   79          
   80          // 全局游戏状态
   81          static game_state_t g_game;
   82          
   83          // 上一次得分，用于判断是否需要刷新
   84          static uint16 g_last_score = 0;
   85          
   86          /********************************************************************************************************
             -*************
   87          * 函数声明
   88          *********************************************************************************************************
             -************/
   89          static void game_init(void);
   90          static void game_reset(void);
   91          static void game_display_start_screen(void);
   92          static void game_display_end_screen(void);
   93          static void game_process_input(void);
   94          static void game_update(void);
   95          static void game_render(void);
   96          static void game_add_player(void);
   97          static void game_add_enemy(void);
   98          static void game_add_bullet(int16 x, int16 y);
   99          static void game_check_collisions(void);
  100          static void game_cleanup_objects(void);
  101          static void game_draw_object(game_object_t *obj, uint16 color);
  102          static void game_update_score(void);
  103          static void game_clear_area(int16 x, int16 y, int16 width, int16 height);
  104          static void game_clear_object(game_object_t *obj);
C251 COMPILER V5.60.0,  game                                                               15/04/25  11:56:12  PAGE 3   

  105          static void game_clear_player_area(game_object_t *player);
  106          
  107          /********************************************************************************************************
             -*************
  108          * 简单绘制一个矩形 - 每2像素画1点，减少50%绘制量
  109          *********************************************************************************************************
             -************/
  110          static void draw_rect(int16 x, int16 y, int16 width, int16 height, uint16 color)
  111          {
  112   1          int16 i;
  113   1          int16 j;
  114   1          int16 x_max;
  115   1          int16 y_max;
  116   1      
  117   1          // 防止越界
  118   1          if (x < 0) 
  119   1          {
  120   2              x = 0;
  121   2          }
  122   1          if (y < 0) 
  123   1          {
  124   2              y = 0;
  125   2          }
  126   1          
  127   1          x_max = x + width;
  128   1          y_max = y + height;
  129   1          
  130   1          if (x_max > SCREEN_WIDTH) 
  131   1          {
  132   2              x_max = SCREEN_WIDTH;
  133   2          }
  134   1          if (y_max > SCREEN_HEIGHT) 
  135   1          {
  136   2              y_max = SCREEN_HEIGHT;
  137   2          }
  138   1          
  139   1          for (i = x; i < x_max; i += 2) 
  140   1          {
  141   2              for (j = y; j < y_max; j += 2) 
  142   2              {
  143   3                  ips200_draw_point(i, j, color);
  144   3              }
  145   2          }
  146   1      }
  147          
  148          /********************************************************************************************************
             -*************
  149          * 清除特定区域 - 优化的区域清除函数
  150          *********************************************************************************************************
             -************/
  151          static void game_clear_area(int16 x, int16 y, int16 width, int16 height)
  152          {
  153   1          int16 i;
  154   1          int16 j;
  155   1          int16 x_max = x + width;
  156   1          int16 y_max = y + height;
  157   1          
  158   1          // 防止越界
  159   1          if (x < GAME_AREA_LEFT) 
  160   1          {
  161   2              x = GAME_AREA_LEFT;
  162   2          }
  163   1          if (y < 0) 
  164   1          {
  165   2              y = 0;
  166   2          }
C251 COMPILER V5.60.0,  game                                                               15/04/25  11:56:12  PAGE 4   

  167   1          if (x_max > SCREEN_WIDTH) 
  168   1          {
  169   2              x_max = SCREEN_WIDTH;
  170   2          }
  171   1          if (y_max > SCREEN_HEIGHT) 
  172   1          {
  173   2              y_max = SCREEN_HEIGHT;
  174   2          }
  175   1          
  176   1          // 更密集地清除每个像素点，确保完全清除
  177   1          for (i = x; i < x_max; i++) 
  178   1          {
  179   2              for (j = y; j < y_max; j++) 
  180   2              {
  181   3                  ips200_draw_point(i, j, COLOR_BG);
  182   3              }
  183   2          }
  184   1      }
  185          
  186          /********************************************************************************************************
             -*************
  187          * 清除特定对象的旧位置
  188          *********************************************************************************************************
             -************/
  189          static void game_clear_object(game_object_t *obj)
  190          {
  191   1          // 确保对象在游戏区域内
  192   1          if (obj->old_x < GAME_AREA_LEFT) 
  193   1          {
  194   2              return;
  195   2          }
  196   1          if (obj->old_y < 0) 
  197   1          {
  198   2              return;
  199   2          }
  200   1          if (obj->old_x >= SCREEN_WIDTH) 
  201   1          {
  202   2              return;
  203   2          }
  204   1          if (obj->old_y >= SCREEN_HEIGHT) 
  205   1          {
  206   2              return;
  207   2          }
  208   1          
  209   1          // 清除对象旧位置的矩形区域
  210   1          game_clear_area(obj->old_x, obj->old_y, obj->width, obj->height);
  211   1      }
  212          
  213          /********************************************************************************************************
             -*************
  214          * 清除玩家及其周围区域 - 优化版清除策略
  215          *********************************************************************************************************
             -************/
  216          static void game_clear_player_area(game_object_t *player)
  217          {
  218   1          int16 clear_x;
  219   1          int16 clear_y;
  220   1          int16 clear_width;
  221   1          int16 clear_height;
  222   1          int16 i;
  223   1          int16 j;
  224   1          int16 x_max;
  225   1          int16 y_max;
  226   1          int16 min_x;
  227   1          int16 min_y;
  228   1          int16 max_x;
C251 COMPILER V5.60.0,  game                                                               15/04/25  11:56:12  PAGE 5   

  229   1          int16 max_y;
  230   1          
  231   1          // 确保对象是玩家
  232   1          if (player->type != GAME_OBJ_PLAYER) 
  233   1          {
  234   2              return;
  235   2          }
  236   1          
  237   1          // 确定包含旧位置和当前位置的最小包围盒
  238   1          min_x = (player->old_x < player->x) ? player->old_x : player->x;
  239   1          min_y = (player->old_y < player->y) ? player->old_y : player->y;
  240   1          max_x = ((player->old_x + player->width) > (player->x + player->width)) ? (player->old_x + player->wi
             -dth) : (player->x + player->width);
  241   1          max_y = ((player->old_y + player->height) > (player->y + player->height)) ? (player->old_y + player->
             -height) : (player->y + player->height);
  242   1          
  243   1          // 增加边距
  244   1          clear_x = min_x - PLAYER_CLEAR_MARGIN;
  245   1          clear_y = min_y - PLAYER_CLEAR_MARGIN;
  246   1          clear_width = (max_x - min_x) + (PLAYER_CLEAR_MARGIN * 2);
  247   1          clear_height = (max_y - min_y) + (PLAYER_CLEAR_MARGIN * 2);
  248   1          
  249   1          // 防止越界
  250   1          if (clear_x < GAME_AREA_LEFT)
  251   1          {
  252   2              clear_x = GAME_AREA_LEFT;
  253   2          }
  254   1          if (clear_y < 0)
  255   1          {
  256   2              clear_y = 0;
  257   2          }
  258   1          
  259   1          // 计算清除区域的最大坐标
  260   1          x_max = clear_x + clear_width;
  261   1          y_max = clear_y + clear_height;
  262   1          
  263   1          if (x_max > SCREEN_WIDTH)
  264   1          {
  265   2              x_max = SCREEN_WIDTH;
  266   2          }
  267   1          if (y_max > SCREEN_HEIGHT)
  268   1          {
  269   2              y_max = SCREEN_HEIGHT;
  270   2          }
  271   1          
  272   1          // 逐像素清除区域
  273   1          for (i = clear_x; i < x_max; i++) 
  274   1          {
  275   2              for (j = clear_y; j < y_max; j++) 
  276   2              {
  277   3                  ips200_draw_point(i, j, COLOR_BG);
  278   3              }
  279   2          }
  280   1      }
  281          
  282          /********************************************************************************************************
             -*************
  283          * 游戏初始化
  284          *********************************************************************************************************
             -************/
  285          static void game_init(void)
  286          {
  287   1          uint8 i;
  288   1          
  289   1          // 初始化游戏状态
  290   1          for (i = 0; i < MAX_OBJECTS; i++) 
C251 COMPILER V5.60.0,  game                                                               15/04/25  11:56:12  PAGE 6   

  291   1          {
  292   2              g_game.objects[i].active = 0;
  293   2          }
  294   1          
  295   1          g_game.obj_count = 0;
  296   1          g_game.score = 0;
  297   1          g_game.game_over = 0;
  298   1          g_last_score = 0;
  299   1          
  300   1          // 设置为横屏显示模式
  301   1          ips200_set_dir(IPS200_CROSSWISE);
  302   1      }
  303          
  304          /********************************************************************************************************
             -*************
  305          * 重置游戏
  306          *********************************************************************************************************
             -************/
  307          static void game_reset(void)
  308          {
  309   1          game_init();
  310   1          game_add_player();
  311   1      }
  312          
  313          /********************************************************************************************************
             -*************
  314          * 显示游戏开始界面
  315          *********************************************************************************************************
             -************/
  316          static void game_display_start_screen(void)
  317          {
  318   1          // 白色背景
  319   1          ips200_clear(COLOR_BG);
  320   1          
  321   1          // 显示游戏标题
  322   1          ips200_show_string(SCREEN_WIDTH/2 - 70, SCREEN_HEIGHT/2 - 20, "HORIZONTAL SHOOTER");
  323   1          ips200_show_string(SCREEN_WIDTH/2 - 70, SCREEN_HEIGHT/2 + 10, "PRESS ANY KEY TO START");
  324   1          
  325   1          // 显示操作说明
  326   1          ips200_show_string(10, SCREEN_HEIGHT - 40, "CONTROLS: UP/DOWN TO MOVE, OK TO SHOOT");
  327   1      }
  328          
  329          /********************************************************************************************************
             -*************
  330          * 显示游戏结束界面
  331          *********************************************************************************************************
             -************/
  332          static void game_display_end_screen(void)
  333          {
  334   1          // 白色背景
  335   1          ips200_clear(COLOR_BG);
  336   1          
  337   1          // 显示游戏结束和分数
  338   1          ips200_show_string(SCREEN_WIDTH/2 - 40, SCREEN_HEIGHT/2 - 30, "GAME OVER");
  339   1          ips200_show_string(SCREEN_WIDTH/2 - 30, SCREEN_HEIGHT/2, "SCORE:");
  340   1          ips200_show_int16(SCREEN_WIDTH/2 + 30, SCREEN_HEIGHT/2, g_game.score);
  341   1          ips200_show_string(SCREEN_WIDTH/2 - 75, SCREEN_HEIGHT/2 + 30, "PRESS ANY KEY TO RETURN");
  342   1      }
  343          
  344          /********************************************************************************************************
             -*************
  345          * 添加玩家飞机 - 横版位置
  346          *********************************************************************************************************
             -************/
  347          static void game_add_player(void)
  348          {
C251 COMPILER V5.60.0,  game                                                               15/04/25  11:56:12  PAGE 7   

  349   1          if (g_game.obj_count >= MAX_OBJECTS) 
  350   1          {
  351   2              return;
  352   2          }
  353   1          
  354   1          g_game.objects[g_game.obj_count].x = GAME_AREA_LEFT + 20;  // 从左侧开始
  355   1          g_game.objects[g_game.obj_count].y = SCREEN_HEIGHT / 2 - PLAYER_HEIGHT / 2;  // 居中
  356   1          g_game.objects[g_game.obj_count].old_x = g_game.objects[g_game.obj_count].x;
  357   1          g_game.objects[g_game.obj_count].old_y = g_game.objects[g_game.obj_count].y;
  358   1          
  359   1          g_game.objects[g_game.obj_count].type = GAME_OBJ_PLAYER;
  360   1          g_game.objects[g_game.obj_count].width = PLAYER_WIDTH;
  361   1          g_game.objects[g_game.obj_count].height = PLAYER_HEIGHT;
  362   1          g_game.objects[g_game.obj_count].active = 1;
  363   1          g_game.objects[g_game.obj_count].moved = 1; // Mark as moved initially to ensure first render clears 
             -area
  364   1          
  365   1          g_game.obj_count++;
  366   1      }
  367          
  368          /********************************************************************************************************
             -*************
  369          * 添加敌人飞机 - 横版位置
  370          *********************************************************************************************************
             -************/
  371          static void game_add_enemy(void)
  372          {
  373   1          uint8 rand_val;
  374   1          int16 y_pos;
  375   1          
  376   1          if (g_game.obj_count >= MAX_OBJECTS) 
  377   1          {
  378   2              return;
  379   2          }
  380   1          
  381   1          rand_val = rand() % 100;
  382   1          if (rand_val >= ENEMY_SPAWN_RATE) 
  383   1          {
  384   2              return;
  385   2          }
  386   1          
  387   1          // 随机纵向位置
  388   1          y_pos = rand() % (SCREEN_HEIGHT - ENEMY_HEIGHT - 10) + 5;
  389   1          
  390   1          // 敌机从右侧生成
  391   1          g_game.objects[g_game.obj_count].x = SCREEN_WIDTH - ENEMY_WIDTH - 5;
  392   1          g_game.objects[g_game.obj_count].y = y_pos;
  393   1          g_game.objects[g_game.obj_count].old_x = g_game.objects[g_game.obj_count].x;
  394   1          g_game.objects[g_game.obj_count].old_y = g_game.objects[g_game.obj_count].y;
  395   1          g_game.objects[g_game.obj_count].type = GAME_OBJ_ENEMY;
  396   1          g_game.objects[g_game.obj_count].width = ENEMY_WIDTH;
  397   1          g_game.objects[g_game.obj_count].height = ENEMY_HEIGHT;
  398   1          g_game.objects[g_game.obj_count].active = 1;
  399   1          g_game.objects[g_game.obj_count].moved = 1;
  400   1          
  401   1          g_game.obj_count++;
  402   1      }
  403          
  404          /********************************************************************************************************
             -*************
  405          * 添加子弹 - 横版发射方向
  406          *********************************************************************************************************
             -************/
  407          static void game_add_bullet(int16 x, int16 y)
  408          {
  409   1          int16 bullet_y;
C251 COMPILER V5.60.0,  game                                                               15/04/25  11:56:12  PAGE 8   

  410   1          uint8 i;
  411   1          static uint8 bullet_count = 0;
  412   1          
  413   1          if (g_game.obj_count >= MAX_OBJECTS) 
  414   1          {
  415   2              return;
  416   2          }
  417   1          
  418   1          // 控制子弹数量，避免过多子弹导致性能问题
  419   1          bullet_count = 0;
  420   1          for (i = 0; i < g_game.obj_count; i++)
  421   1          {
  422   2              if (g_game.objects[i].type == GAME_OBJ_BULLET && g_game.objects[i].active)
  423   2              {
  424   3                  bullet_count++;
  425   3              }
  426   2          }
  427   1          
  428   1          // 最多同时3颗子弹
  429   1          if (bullet_count >= 3)
  430   1          {
  431   2              return;
  432   2          }
  433   1          
  434   1          // 子弹从飞机右侧中央发射
  435   1          bullet_y = y + (PLAYER_HEIGHT / 2) - (BULLET_HEIGHT / 2);
  436   1          
  437   1          g_game.objects[g_game.obj_count].x = x + PLAYER_WIDTH;
  438   1          g_game.objects[g_game.obj_count].y = bullet_y;
  439   1          g_game.objects[g_game.obj_count].old_x = g_game.objects[g_game.obj_count].x;
  440   1          g_game.objects[g_game.obj_count].old_y = g_game.objects[g_game.obj_count].y;
  441   1          g_game.objects[g_game.obj_count].type = GAME_OBJ_BULLET;
  442   1          g_game.objects[g_game.obj_count].width = BULLET_WIDTH;
  443   1          g_game.objects[g_game.obj_count].height = BULLET_HEIGHT;
  444   1          g_game.objects[g_game.obj_count].active = 1;
  445   1          g_game.objects[g_game.obj_count].moved = 1;
  446   1          
  447   1          g_game.obj_count++;
  448   1      }
  449          
  450          /********************************************************************************************************
             -*************
  451          * 处理按键输入 - 上下摇杆移动和确定键射击
  452          *********************************************************************************************************
             -************/
  453          static void game_process_input(void)
  454          {
  455   1          uint8 i;
  456   1          uint8 key_up;
  457   1          uint8 key_down;
  458   1          uint8 key_fire;              // 确定键
  459   1          static uint8 fire_cooldown = 0;
  460   1          uint8 player_moved = 0;
  461   1          
  462   1          // 读取按键状态
  463   1          key_up = !gpio_get_level(KEY_4);     // 上摇键
  464   1          key_down = !gpio_get_level(KEY_3);   // 下摇键
  465   1          key_fire = !gpio_get_level(KEY_5);   // 确定键用于射击
  466   1          
  467   1          // 寻找玩家飞机
  468   1          for (i = 0; i < g_game.obj_count; i++) 
  469   1          {
  470   2              if (g_game.objects[i].type == GAME_OBJ_PLAYER && g_game.objects[i].active) 
  471   2              {
  472   3                  // 保存旧位置
  473   3                  g_game.objects[i].old_x = g_game.objects[i].x;
C251 COMPILER V5.60.0,  game                                                               15/04/25  11:56:12  PAGE 9   

  474   3                  g_game.objects[i].old_y = g_game.objects[i].y;
  475   3                  
  476   3                  // 上移
  477   3                  if (key_up && g_game.objects[i].y > 5) 
  478   3                  {
  479   4                      g_game.objects[i].y -= PLAYER_SPEED;
  480   4                      player_moved = 1;
  481   4                  }
  482   3                  
  483   3                  // 下移
  484   3                  if (key_down && g_game.objects[i].y < SCREEN_HEIGHT - PLAYER_HEIGHT - 5) 
  485   3                  {
  486   4                      g_game.objects[i].y += PLAYER_SPEED;
  487   4                      player_moved = 1;
  488   4                  }
  489   3                  
  490   3                  // 如果玩家飞机位置有变化，标记为需要重绘和清除
  491   3                  if (player_moved) 
  492   3                  {
  493   4                      g_game.objects[i].moved = 1;
  494   4                  }
  495   3                  
  496   3                  // 发射子弹 - 使用确定键
  497   3                  if (key_fire && fire_cooldown == 0) 
  498   3                  {
  499   4                      game_add_bullet(g_game.objects[i].x, g_game.objects[i].y);
  500   4                      fire_cooldown = 3;
  501   4                  }
  502   3                  
  503   3                  break;
  504   3              }
  505   2          }
  506   1          
  507   1          // 更新发射冷却时间
  508   1          if (fire_cooldown > 0) 
  509   1          {
  510   2              fire_cooldown--;
  511   2          }
  512   1      }
  513          
  514          /********************************************************************************************************
             -*************
  515          * 更新游戏状态 - 横版逻辑
  516          *********************************************************************************************************
             -************/
  517          static void game_update(void)
  518          {
  519   1          uint8 i;
  520   1          
  521   1          // 更新所有对象
  522   1          for (i = 0; i < g_game.obj_count; i++) 
  523   1          {
  524   2              if (!g_game.objects[i].active) 
  525   2              {
  526   3                  continue;
  527   3              }
  528   2              
  529   2              // 保存旧位置
  530   2              g_game.objects[i].old_x = g_game.objects[i].x;
  531   2              g_game.objects[i].old_y = g_game.objects[i].y;
  532   2              
  533   2              // 根据对象类型更新位置
  534   2              if (g_game.objects[i].type == GAME_OBJ_ENEMY) 
  535   2              {
  536   3                  // 敌机向左移动
  537   3                  g_game.objects[i].x -= ENEMY_SPEED;
C251 COMPILER V5.60.0,  game                                                               15/04/25  11:56:12  PAGE 10  

  538   3                  g_game.objects[i].moved = 1;
  539   3                  
  540   3                  // 超出屏幕左侧则清除并停用
  541   3                  if (g_game.objects[i].x + g_game.objects[i].width < GAME_AREA_LEFT) // Check if fully off-scr
             -een
  542   3                  {
  543   4                      // Clear before deactivating
  544   4                      game_clear_object(&g_game.objects[i]); 
  545   4                      g_game.objects[i].active = 0;
  546   4                  }
  547   3              }
  548   2              else if (g_game.objects[i].type == GAME_OBJ_BULLET) 
  549   2              {
  550   3                  // 子弹向右移动
  551   3                  g_game.objects[i].x += BULLET_SPEED;
  552   3                  g_game.objects[i].moved = 1;
  553   3                  
  554   3                  // 超出屏幕右侧则清除并停用
  555   3                  if (g_game.objects[i].x > SCREEN_WIDTH) 
  556   3                  {
  557   4                      // Clear before deactivating
  558   4                      game_clear_object(&g_game.objects[i]);
  559   4                      g_game.objects[i].active = 0;
  560   4                  }
  561   3              }
  562   2          }
  563   1          
  564   1          // 检查碰撞
  565   1          game_check_collisions();
  566   1          
  567   1          // 清理无效对象
  568   1          game_cleanup_objects();
  569   1          
  570   1          // 尝试生成新敌机
  571   1          game_add_enemy();
  572   1      }
  573          
  574          /********************************************************************************************************
             -*************
  575          * 检查碰撞
  576          *********************************************************************************************************
             -************/
  577          static void game_check_collisions(void)
  578          {
  579   1          uint8 i;
  580   1          uint8 j;
  581   1          game_object_t *obj1;
  582   1          game_object_t *obj2;
  583   1          game_object_t *enemy_to_clear = NULL; // Pointer to store enemy to be cleared
  584   1          game_object_t *bullet_to_clear = NULL; // Pointer to store bullet to be cleared
  585   1      
  586   1          for (i = 0; i < g_game.obj_count; i++) 
  587   1          {
  588   2              obj1 = &g_game.objects[i];
  589   2              enemy_to_clear = NULL; // Reset for each obj1 iteration
  590   2              bullet_to_clear = NULL;
  591   2              
  592   2              if (!obj1->active) 
  593   2              {
  594   3                  continue;
  595   3              }
  596   2              
  597   2              for (j = i + 1; j < g_game.obj_count; j++) 
  598   2              {
  599   3                  obj2 = &g_game.objects[j];
  600   3                  
C251 COMPILER V5.60.0,  game                                                               15/04/25  11:56:12  PAGE 11  

  601   3                  if (!obj2->active) 
  602   3                  {
  603   4                      continue;
  604   4                  }
  605   3                  
  606   3                  // 矩形碰撞检测
  607   3                  if (obj1->x < obj2->x + obj2->width && 
  608   3                      obj1->x + obj1->width > obj2->x && 
  609   3                      obj1->y < obj2->y + obj2->height && 
  610   3                      obj1->y + obj1->height > obj2->y) 
  611   3                  {
  612   4                      
  613   4                      // 子弹击中敌机
  614   4                      if ((obj1->type == GAME_OBJ_BULLET && obj2->type == GAME_OBJ_ENEMY)) 
  615   4                      {
  616   5                          bullet_to_clear = obj1; // Mark bullet for clearing
  617   5                          enemy_to_clear = obj2;  // Mark enemy for clearing
  618   5                          g_game.score += SCORE_PER_ENEMY;
  619   5                      }
  620   4                      else if ((obj1->type == GAME_OBJ_ENEMY && obj2->type == GAME_OBJ_BULLET))
  621   4                      {
  622   5                          enemy_to_clear = obj1;  // Mark enemy for clearing
  623   5                          bullet_to_clear = obj2; // Mark bullet for clearing
  624   5                          g_game.score += SCORE_PER_ENEMY;
  625   5                      }
  626   4                      // 玩家碰到敌机
  627   4                      else if ((obj1->type == GAME_OBJ_PLAYER && obj2->type == GAME_OBJ_ENEMY) ||
  628   4                               (obj1->type == GAME_OBJ_ENEMY && obj2->type == GAME_OBJ_PLAYER)) 
  629   4                      {
  630   5                          g_game.game_over = 1;
  631   5                      }
  632   4                  }
  633   3                  
  634   3                  // If an enemy or bullet was marked for clearing, clear and deactivate them now
  635   3                  if (enemy_to_clear != NULL)
  636   3                  {
  637   4                      game_clear_object(enemy_to_clear); // Clear the enemy wreckage
  638   4                      enemy_to_clear->active = 0;        // Deactivate enemy
  639   4                      enemy_to_clear = NULL;             // Reset the pointer
  640   4                  }
  641   3                   if (bullet_to_clear != NULL)
  642   3                  {
  643   4                      game_clear_object(bullet_to_clear); // Clear the bullet
  644   4                      bullet_to_clear->active = 0;         // Deactivate bullet
  645   4                      bullet_to_clear = NULL;              // Reset the pointer
  646   4                  }
  647   3              } // End inner loop (j)
  648   2      
  649   2              // Clearing logic moved inside inner loop to handle multiple collisions correctly
  650   2          } // End outer loop (i)
  651   1      }
  652          
  653          /********************************************************************************************************
             -*************
  654          * 清理无效对象
  655          *********************************************************************************************************
             -************/
  656          static void game_cleanup_objects(void)
  657          {
  658   1          uint8 i;
  659   1          uint8 active_count;
  660   1          
  661   1          active_count = 0;
  662   1          
  663   1          // 压缩数组 - 将活动对象移到前面
  664   1          for (i = 0; i < g_game.obj_count; i++) 
C251 COMPILER V5.60.0,  game                                                               15/04/25  11:56:12  PAGE 12  

  665   1          {
  666   2              if (g_game.objects[i].active) 
  667   2              {
  668   3                  if (i != active_count) 
  669   3                  {
  670   4                      g_game.objects[active_count] = g_game.objects[i];
  671   4                  }
  672   3                  active_count++;
  673   3              }
  674   2          }
  675   1          
  676   1          g_game.obj_count = active_count;
  677   1      }
  678          
  679          /********************************************************************************************************
             -*************
  680          * 渲染游戏 - 对象级别的清除和绘制，优化性能
  681          *********************************************************************************************************
             -************/
  682          static void game_render(void)
  683          {
  684   1          uint8 i;
  685   1          static uint8 first_render = 1;
  686   1          
  687   1          // 更新分数
  688   1          game_update_score();
  689   1          
  690   1          // 首次渲染时清屏并绘制分隔线
  691   1          if (first_render) 
  692   1          {
  693   2              // 完全清屏
  694   2              ips200_clear(COLOR_BG);
  695   2              
  696   2              // 绘制分隔线
  697   2              for (i = 0; i < SCREEN_HEIGHT; i += 2) 
  698   2              {
  699   3                  ips200_draw_point(GAME_AREA_LEFT - 1, i, COLOR_TEXT);
  700   3              }
  701   2              first_render = 0;
  702   2          }
  703   1          else
  704   1          {
  705   2              // 逐个清除对象，玩家使用特殊清除方法
  706   2              for (i = 0; i < g_game.obj_count; i++) 
  707   2              {
  708   3                  if (g_game.objects[i].active) 
  709   3                  {
  710   4                      // 对玩家，如果移动过，则清除旧区域
  711   4                      if (g_game.objects[i].type == GAME_OBJ_PLAYER && g_game.objects[i].moved)
  712   4                      {
  713   5                          game_clear_player_area(&g_game.objects[i]);
  714   5                      }
  715   4                      // 对其他对象，如果移动过，则清除旧区域
  716   4                      else if (g_game.objects[i].moved) 
  717   4                      {
  718   5                          // Only clear if coordinates actually changed to avoid redundant clears
  719   5                           if (g_game.objects[i].x != g_game.objects[i].old_x || 
  720   5                               g_game.objects[i].y != g_game.objects[i].old_y)
  721   5                           {
  722   6                               game_clear_object(&g_game.objects[i]);
  723   6                           }
  724   5                      }
  725   4                  }
  726   3                  // IMPORTANT: Do not clear inactive objects here, enemy wreckage/offscreen is cleared elsewhe
             -re
  727   3              }
C251 COMPILER V5.60.0,  game                                                               15/04/25  11:56:12  PAGE 13  

  728   2              
  729   2              // 清除左侧边界足够宽的区域以处理离开屏幕的敌机
  730   2              game_clear_area(GAME_AREA_LEFT, 0, BORDER_CLEAR_WIDTH, SCREEN_HEIGHT);
  731   2          }
  732   1          
  733   1          // 绘制所有活动对象
  734   1          for (i = 0; i < g_game.obj_count; i++) 
  735   1          {
  736   2              if (g_game.objects[i].active) 
  737   2              {
  738   3                  // 根据对象类型绘制
  739   3                  if (g_game.objects[i].type == GAME_OBJ_PLAYER) 
  740   3                  {
  741   4                      game_draw_object(&g_game.objects[i], COLOR_PLAYER);
  742   4                  }
  743   3                  else if (g_game.objects[i].type == GAME_OBJ_ENEMY) 
  744   3                  {
  745   4                      game_draw_object(&g_game.objects[i], COLOR_ENEMY);
  746   4                  }
  747   3                  else if (g_game.objects[i].type == GAME_OBJ_BULLET) 
  748   3                  {
  749   4                      game_draw_object(&g_game.objects[i], COLOR_BULLET);
  750   4                  }
  751   3                  
  752   3                  // 重置移动标志 AFTER drawing
  753   3                  g_game.objects[i].moved = 0;
  754   3              }
  755   2          }
  756   1      }
  757          
  758          /********************************************************************************************************
             -*************
  759          * 绘制游戏对象 - 完整像素填充
  760          *********************************************************************************************************
             -************/
  761          static void game_draw_object(game_object_t *obj, uint16 color)
  762          {
  763   1          int16 i;
  764   1          int16 j;
  765   1          int16 x_max;
  766   1          int16 y_max;
  767   1          int16 x = obj->x;
  768   1          int16 y = obj->y;
  769   1          
  770   1          // 防止越界
  771   1          if (x < GAME_AREA_LEFT) 
  772   1          {
  773   2              x = GAME_AREA_LEFT;
  774   2          }
  775   1          if (y < 0) 
  776   1          {
  777   2              y = 0;
  778   2          }
  779   1          
  780   1          x_max = x + obj->width;
  781   1          y_max = y + obj->height;
  782   1          
  783   1          if (x_max > SCREEN_WIDTH) 
  784   1          {
  785   2              x_max = SCREEN_WIDTH;
  786   2          }
  787   1          if (y_max > SCREEN_HEIGHT) 
  788   1          {
  789   2              y_max = SCREEN_HEIGHT;
  790   2          }
  791   1          
C251 COMPILER V5.60.0,  game                                                               15/04/25  11:56:12  PAGE 14  

  792   1          // 使用完整填充绘制对象
  793   1          for (i = x; i < x_max; i++) 
  794   1          {
  795   2              for (j = y; j < y_max; j++) 
  796   2              {
  797   3                  ips200_draw_point(i, j, color);
  798   3              }
  799   2          }
  800   1      }
  801          
  802          /********************************************************************************************************
             -*************
  803          * 更新分数显示 - 左上角
  804          *********************************************************************************************************
             -************/
  805          static void game_update_score(void)
  806          {
  807   1          if (g_game.score != g_last_score) 
  808   1          {
  809   2              // 清除旧分数区域
  810   2              draw_rect(10, 5, 90, 15, COLOR_BG);
  811   2              
  812   2              // 显示新分数
  813   2              ips200_show_string(10, 5, "SCORE:");
  814   2              ips200_show_int16(60, 5, g_game.score);
  815   2              
  816   2              // 更新缓存的分数
  817   2              g_last_score = g_game.score;
  818   2          }
  819   1      }
  820          
  821          /********************************************************************************************************
             -*************
  822          * 游戏主函数
  823          *********************************************************************************************************
             -************/
  824          void function_game(void)
  825          {
  826   1          uint8 key_any;
  827   1          
  828   1          // 初始化游戏
  829   1          game_init();
  830   1          
  831   1          // 显示开始界面
  832   1          game_display_start_screen();
  833   1          
  834   1          // 等待任意按键开始
  835   1          while (1) 
  836   1          {
  837   2              key_any = !gpio_get_level(KEY_1) || !gpio_get_level(KEY_2) || 
  838   2                       !gpio_get_level(KEY_3) || !gpio_get_level(KEY_4) || 
  839   2                       !gpio_get_level(KEY_5);
  840   2              
  841   2              if (key_any) 
  842   2              {
  843   3                  break;
  844   3              }
  845   2              
  846   2              system_delay_ms(50);
  847   2          }
  848   1          
  849   1          // 等待按键释放
  850   1          while (!gpio_get_level(KEY_1) || !gpio_get_level(KEY_2) || 
  851   1                 !gpio_get_level(KEY_3) || !gpio_get_level(KEY_4) || 
  852   1                 !gpio_get_level(KEY_5)) 
  853   1          {
C251 COMPILER V5.60.0,  game                                                               15/04/25  11:56:12  PAGE 15  

  854   2              system_delay_ms(10);
  855   2          }
  856   1          
  857   1          // 重置游戏并初始化显示
  858   1          game_reset();
  859   1          ips200_clear(COLOR_BG);
  860   1          
  861   1          // 游戏主循环
  862   1          while (!g_game.game_over) 
  863   1          {
  864   2              // 处理输入
  865   2              game_process_input();
  866   2              
  867   2              // 更新游戏状态
  868   2              game_update();
  869   2              
  870   2              // 渲染游戏
  871   2              game_render();
  872   2              
  873   2              // 控制帧率
  874   2              system_delay_ms(10);
  875   2          }
  876   1          
  877   1          // 显示游戏结束界面
  878   1          game_display_end_screen();
  879   1          
  880   1          // 等待按键释放
  881   1          system_delay_ms(300);
  882   1          while (!gpio_get_level(KEY_1) || !gpio_get_level(KEY_2) || 
  883   1                 !gpio_get_level(KEY_3) || !gpio_get_level(KEY_4) || 
  884   1                 !gpio_get_level(KEY_5)) 
  885   1          {
  886   2              system_delay_ms(10);
  887   2          }
  888   1          
  889   1          // 等待任意按键返回
  890   1          while (1) 
  891   1          {
  892   2              key_any = !gpio_get_level(KEY_1) || !gpio_get_level(KEY_2) || 
  893   2                       !gpio_get_level(KEY_3) || !gpio_get_level(KEY_4) || 
  894   2                       !gpio_get_level(KEY_5);
  895   2              
  896   2              if (key_any) 
  897   2              {
  898   3                  break;
  899   3              }
  900   2              
  901   2              system_delay_ms(50);
  902   2          }
  903   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      6592     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       327     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
C251 COMPILER V5.60.0,  game                                                               15/04/25  11:56:12  PAGE 16  

  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       147     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
