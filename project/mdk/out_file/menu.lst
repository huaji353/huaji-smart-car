C251 COMPILER V5.60.0,  menu                                                               12/06/25  20:23:03  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE menu
OBJECT MODULE PLACED IN .\out_file\menu.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE ..\code\menu.c LARGE NOALIAS WARNINGLEVEL(3) OPTIMIZE(1,SIZE) BROWSE I
                    -NCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver;..\use
                    -r;..\code) DEBUG PRINT(.\out_file\menu.lst) TABS(2) OBJECT(.\out_file\menu.obj) 

stmt  level    source

    1          #include "zf_common_headfile.h"
    2          
    3          // 定义示例变量，这些变量可以在菜单功能中使用
    4          int16 speed_value = 0;
    5          uint8 seekfree_flag = 0;
    6          uint8 inductance_max_min_flag = 0;
    7          // 定义菜单
    8          menu_page_t menu_pages[17];
    9          
   10          // 菜单状态
   11          menu_state_t menu_state;
   12          
   13          // 主菜单页索引
   14          
   15          #define MAIN_MENU_INDEX 0
   16          
   17          
   18          // 声明测试函数
   19          extern void key_text(void);
   20          extern void adc_text(void);
   21          extern void encoder_text(void);
   22          extern void ips_text(void);
   23          extern void uart_printf_test(void);
   24          extern void quaternion_display(void);
   25          
   26          // 声明游戏函数
   27          #if game_open
               extern void function_game(void);
               extern void function_snake(void);
               #endif
   31          // 声明左右轮PID设置函数
   32          void function_left_motor_pid_setting(void);
   33          void function_right_motor_pid_setting(void);
   34          
   35          //开启逐飞传输
   36          void seekfree_assistant_open(void)
   37          {
   38   1          uint8 exit_flag = 0;
   39   1          seekfree_flag = !seekfree_flag;
   40   1          // 清屏
   41   1          ips200_clear(RGB565_WHITE);
   42   1          while (!exit_flag) {
   43   2          button_entry();
   44   2          ips200_show_string(100, 100, "Seekfree_flag");
   45   2          sprintf(txt, "%d", seekfree_flag);
   46   2          ips200_show_string(80, 120, txt);
   47   2          // 检测退出按键
   48   2          if (button5) {
   49   3              exit_flag = 1;
   50   3          }
   51   2          system_delay_ms(1);
   52   2          }
   53   1      }
   54          //开启电感最值判断
   55          void function_inductance_max_min_setting(void)
   56          {
   57   1          uint8 exit_flag = 0;
C251 COMPILER V5.60.0,  menu                                                               12/06/25  20:23:03  PAGE 2   

   58   1          inductance_max_min_flag = !inductance_max_min_flag;
   59   1          // 清屏
   60   1          ips200_clear(RGB565_WHITE);
   61   1          while (!exit_flag) {
   62   2          button_entry();
   63   2          inductance_judgment();
   64   2          // 检测退出按键
   65   2          if (button5) {
   66   3              exit_flag = 1;
   67   3          }
   68   2          system_delay_ms(1);
   69   2          }
   70   1          eeprom_write_inductance_max_min();
   71   1      }
   72          
   73          #if text_open //测试功能封装函数
   74          // 测试功能封装函数
   75          //开启电感最值显示
   76          void function_inductance_max_min_show(void)
   77          {
   78   1          uint8 exit_flag = 0;
   79   1          // 清屏
   80   1          ips200_clear(RGB565_WHITE);
   81   1          
   82   1          while (!exit_flag) {
   83   2              // 显示电感最大值
   84   2              sprintf(txt, "H1_max: %.2f", inductance_horizontal_1_max);
   85   2              ips200_show_string(0, 0, txt);
   86   2              
   87   2              sprintf(txt, "V2_max: %.2f", inductance_vertical_2_max);
   88   2              ips200_show_string(0, 16, txt);
   89   2              
   90   2              sprintf(txt, "V3_max: %.2f", inductance_vertical_3_max);
   91   2              ips200_show_string(0, 32, txt);
   92   2              
   93   2              sprintf(txt, "H4_max: %.2f", inductance_horizontal_4_max);
   94   2              ips200_show_string(0, 48, txt);
   95   2              
   96   2              // 显示电感最小值
   97   2              sprintf(txt, "H1_min: %.2f", inductance_horizontal_1_min);
   98   2              ips200_show_string(0, 80, txt);
   99   2              
  100   2              sprintf(txt, "V2_min: %.2f", inductance_vertical_2_min);
  101   2              ips200_show_string(0, 96, txt);
  102   2              
  103   2              sprintf(txt, "V3_min: %.2f", inductance_vertical_3_min);
  104   2              ips200_show_string(0, 112, txt);
  105   2              
  106   2              sprintf(txt, "H4_min: %.2f", inductance_horizontal_4_min);
  107   2              ips200_show_string(0, 128, txt);
  108   2              
  109   2              // 检测按键
  110   2              button_entry();
  111   2              if (button5) {
  112   3                  exit_flag = 1;
  113   3              }
  114   2              
  115   2              // 延时刷新
  116   2              system_delay_ms(100);
  117   2          }
  118   1      }
  119          void function_key_test(void) {
  120   1          uint8 exit_flag = 0;
  121   1          button5 = 0;
  122   1          
  123   1          // 清屏
C251 COMPILER V5.60.0,  menu                                                               12/06/25  20:23:03  PAGE 3   

  124   1          ips200_clear(RGB565_WHITE);
  125   1          while (!exit_flag) {
  126   2              button_entry();
  127   2              // 调用按键测试函数
  128   2              key_text();
  129   2              
  130   2              // 检测退出按键
  131   2              if (button5) {
  132   3                  exit_flag = 1;
  133   3              }
  134   2              system_delay_ms(10);
  135   2          }
  136   1      }
  137          void function_imu_test(void) {
  138   1          uint8 exit_flag = 0;
  139   1          button5 = 0;
  140   1          
  141   1          // 清屏
  142   1          ips200_clear(RGB565_WHITE);
  143   1          while (!exit_flag) {
  144   2              button_entry();
  145   2              // 调用IMU测试函数
  146   2              quaternion_display();
  147   2              // imu660ra_text();
  148   2              // 检测退出按键
  149   2              if (button5) {
  150   3                  exit_flag = 1;
  151   3              }
  152   2              system_delay_ms(5);
  153   2          }
  154   1      }       
  155          void function_uart_printf_test(void) {
  156   1          uint8 exit_flag = 0;
  157   1          button5 = 0;
  158   1          
  159   1          // 清屏
  160   1          ips200_clear(RGB565_WHITE);
  161   1      
  162   1          while (!exit_flag) {
  163   2              button_entry();
  164   2              // 调用UART测试函数
  165   2              uart_printf_test(); 
  166   2              
  167   2              // 检测退出按键
  168   2              if (button5) {
  169   3                  exit_flag = 1;
  170   3              }   
  171   2              system_delay_ms(10);
  172   2          }
  173   1      }
  174          
  175          
  176          void function_adc_test(void) {
  177   1          uint8 exit_flag = 0;
  178   1          button5 = 0;
  179   1          
  180   1          // 清屏
  181   1          ips200_clear(RGB565_WHITE);
  182   1          
  183   1          while (!exit_flag) {
  184   2              button_entry();
  185   2              // 调用ADC测试函数
  186   2              adc_main_read();
  187   2              // inductance_normalization_max();
  188   2              inductance_difference_ratio_sum();
  189   2              adc_text();
C251 COMPILER V5.60.0,  menu                                                               12/06/25  20:23:03  PAGE 4   

  190   2              
  191   2              // 检测退出按键
  192   2              if (button5) {
  193   3                  exit_flag = 1;
  194   3              }
  195   2              system_delay_ms(10);
  196   2          }
  197   1      }
  198          
  199          void function_encoder_test(void) {
  200   1          uint8 exit_flag = 0;
  201   1          button5 = 0;
  202   1          
  203   1          // 清屏
  204   1          ips200_clear(RGB565_WHITE);
  205   1          
  206   1          while (!exit_flag) {
  207   2              button_entry();
  208   2              // 调用编码器测试函数
  209   2              encoder_text();
  210   2              
  211   2              // 检测退出按键
  212   2              if (button5) {
  213   3                  exit_flag = 1;
  214   3              }
  215   2              system_delay_ms(10);
  216   2          }
  217   1      }
  218          
  219          void function_ips_test(void) {
  220   1          uint8 exit_flag = 0;
  221   1          button5 = 0;
  222   1          
  223   1          // 清屏
  224   1          ips200_clear(RGB565_WHITE);
  225   1          
  226   1          while (!exit_flag) {
  227   2              button_entry();
  228   2              // 调用IPS显示测试函数
  229   2              ips_text();
  230   2              
  231   2              // 检测退出按键
  232   2              if (button5) {
  233   3                  exit_flag = 1;
  234   3              }
  235   2              system_delay_ms(10);
  236   2          }
  237   1      }
  238          void function_buzzer_test(void) {
  239   1          uint8 exit_flag = 0;
  240   1          button5 = 0;
  241   1          
  242   1          // 清屏
  243   1          ips200_clear(RGB565_WHITE);
  244   1          
  245   1          while (!exit_flag) {
  246   2              button_entry();
  247   2              // 调用蜂鸣器测试函数
  248   2              buzzer_time(100);
  249   2              
  250   2              // 检测退出按键 
  251   2              if (button5) {
  252   3                  exit_flag = 1;
  253   3              }
  254   2              system_delay_ms(10);
  255   2          }
C251 COMPILER V5.60.0,  menu                                                               12/06/25  20:23:03  PAGE 5   

  256   1      }  
  257          // 添加 image_path 测试函数
  258          void function_image_path_test(void) {
  259   1          uint8 exit_flag = 0;
  260   1          button5 = 0;
  261   1          
  262   1          // 清屏
  263   1          ips200_clear(RGB565_WHITE);
  264   1          
  265   1          while (!exit_flag) {
  266   2              button_entry();
  267   2              #if image_open
                       // 调用路径绘制函数
                       image_path();
                       // 检测退出按键
                       #endif
  272   2              if (button5) {
  273   3                  exit_flag = 1;
  274   3              }
  275   2              system_delay_ms(5);
  276   2          }
  277   1      }
  278          #endif
  279          // 初始化菜单系统
  280          void menu_init(void) {
  281   1          // 初始化菜单状态
  282   1          menu_state.current_level = 0;
  283   1          menu_state.current_page[0] = MAIN_MENU_INDEX;
  284   1          menu_state.current_index[0] = 0;
  285   1          
  286   1          // 初始化主菜单
  287   1          strcpy(menu_pages[MAIN_MENU_INDEX].title, "MAIN MENU");
  288   1          menu_pages[MAIN_MENU_INDEX].item_count = 7; // 增加菜单项数
  289   1          
  290   1          // 设置主菜单项
  291   1          strcpy(menu_pages[MAIN_MENU_INDEX].items[0].name, "Settings");
  292   1          menu_pages[MAIN_MENU_INDEX].items[0].function = NULL;
  293   1          menu_pages[MAIN_MENU_INDEX].items[0].has_child = 1;
  294   1          menu_pages[MAIN_MENU_INDEX].items[0].child_index = SETTING_MENU_INDEX;
  295   1          
  296   1          strcpy(menu_pages[MAIN_MENU_INDEX].items[1].name, "PID Parameters");
  297   1          menu_pages[MAIN_MENU_INDEX].items[1].function = NULL;
  298   1          menu_pages[MAIN_MENU_INDEX].items[1].has_child = 1;
  299   1          menu_pages[MAIN_MENU_INDEX].items[1].child_index = PID_MENU_INDEX;
  300   1          
  301   1          strcpy(menu_pages[MAIN_MENU_INDEX].items[2].name, "Tests");
  302   1          menu_pages[MAIN_MENU_INDEX].items[2].function = NULL;
  303   1          menu_pages[MAIN_MENU_INDEX].items[2].has_child = 1;
  304   1          menu_pages[MAIN_MENU_INDEX].items[2].child_index = TEST_MENU_INDEX;
  305   1          
  306   1          strcpy(menu_pages[MAIN_MENU_INDEX].items[3].name, "Calibration");
  307   1          menu_pages[MAIN_MENU_INDEX].items[3].function = function_sensor_calibration;
  308   1          menu_pages[MAIN_MENU_INDEX].items[3].has_child = 0;
  309   1          #if game_open
                    // 添加游戏菜单
                   strcpy(menu_pages[MAIN_MENU_INDEX].items[4].name, "Games");
                   menu_pages[MAIN_MENU_INDEX].items[5].function = NULL;
                   menu_pages[MAIN_MENU_INDEX].items[5].has_child = 1;
                   menu_pages[MAIN_MENU_INDEX].items[5].child_index = GAME_MENU_INDEX;
                   #endif
  316   1      
  317   1          strcpy(menu_pages[MAIN_MENU_INDEX].items[4].name, "Seekfree");
  318   1          menu_pages[MAIN_MENU_INDEX].items[4].function = seekfree_assistant_open;
  319   1          menu_pages[MAIN_MENU_INDEX].items[4].has_child = 0;
  320   1      
  321   1          strcpy(menu_pages[MAIN_MENU_INDEX].items[5].name, "Inductance Max Min");
C251 COMPILER V5.60.0,  menu                                                               12/06/25  20:23:03  PAGE 6   

  322   1          menu_pages[MAIN_MENU_INDEX].items[5].function = function_inductance_max_min_setting;
  323   1          menu_pages[MAIN_MENU_INDEX].items[5].has_child = 0;
  324   1          
  325   1          // 初始化子菜单
  326   1          strcpy(menu_pages[SETTING_MENU_INDEX].title, "SETTINGS");
  327   1          menu_pages[SETTING_MENU_INDEX].item_count = 3;
  328   1          
  329   1          strcpy(menu_pages[SETTING_MENU_INDEX].items[0].name, "Speed");
  330   1          menu_pages[SETTING_MENU_INDEX].items[0].function = function_speed_setting;
  331   1          menu_pages[SETTING_MENU_INDEX].items[0].has_child = 0;
  332   1          
  333   1          strcpy(menu_pages[SETTING_MENU_INDEX].items[1].name, "Display Mode");
  334   1          menu_pages[SETTING_MENU_INDEX].items[1].function = function_dummy;
  335   1          menu_pages[SETTING_MENU_INDEX].items[1].has_child = 0;
  336   1          
  337   1          strcpy(menu_pages[SETTING_MENU_INDEX].items[2].name, "Back");
  338   1          menu_pages[SETTING_MENU_INDEX].items[2].function = NULL;
  339   1          menu_pages[SETTING_MENU_INDEX].items[2].has_child = 0;
  340   1          
  341   1          // 初始化PID子菜单页
  342   1          strcpy(menu_pages[PID_MENU_INDEX].title, "PID PARAMETERS");
  343   1          menu_pages[PID_MENU_INDEX].item_count = 6;  // 增加菜单项数
  344   1          
  345   1          strcpy(menu_pages[PID_MENU_INDEX].items[0].name, "Angle PID");
  346   1          menu_pages[PID_MENU_INDEX].items[0].function = NULL;
  347   1          menu_pages[PID_MENU_INDEX].items[0].has_child = 1;
  348   1          menu_pages[PID_MENU_INDEX].items[0].child_index = ANGLE_PID_MENU_INDEX;
  349   1          
  350   1          strcpy(menu_pages[PID_MENU_INDEX].items[1].name, "Angle Speed PID");
  351   1          menu_pages[PID_MENU_INDEX].items[1].function = NULL;
  352   1          menu_pages[PID_MENU_INDEX].items[1].has_child = 1;
  353   1          menu_pages[PID_MENU_INDEX].items[1].child_index = ANGLE_SPEED_PID_MENU_INDEX;
  354   1          
  355   1          strcpy(menu_pages[PID_MENU_INDEX].items[2].name, "Left Motor PID");
  356   1          menu_pages[PID_MENU_INDEX].items[2].function = NULL;
  357   1          menu_pages[PID_MENU_INDEX].items[2].has_child = 1;
  358   1          menu_pages[PID_MENU_INDEX].items[2].child_index = LEFT_MOTOR_PID_MENU_INDEX;
  359   1      
  360   1          strcpy(menu_pages[PID_MENU_INDEX].items[3].name, "Right Motor PID");
  361   1          menu_pages[PID_MENU_INDEX].items[3].function = NULL;
  362   1          menu_pages[PID_MENU_INDEX].items[3].has_child = 1;
  363   1          menu_pages[PID_MENU_INDEX].items[3].child_index = RIGHT_MOTOR_PID_MENU_INDEX;
  364   1          
  365   1          // 添加重置PID参数选项
  366   1          strcpy(menu_pages[PID_MENU_INDEX].items[4].name, "Reset All PID");
  367   1          menu_pages[PID_MENU_INDEX].items[4].function = function_reset_pid;
  368   1          menu_pages[PID_MENU_INDEX].items[4].has_child = 0;
  369   1          
  370   1          strcpy(menu_pages[PID_MENU_INDEX].items[5].name, "Back");
  371   1          menu_pages[PID_MENU_INDEX].items[5].function = NULL;
  372   1          menu_pages[PID_MENU_INDEX].items[5].has_child = 0;
  373   1          
  374   1          // 初始化角度PID子菜单页
  375   1          strcpy(menu_pages[ANGLE_PID_MENU_INDEX].title, "ANGLE PID");
  376   1          menu_pages[ANGLE_PID_MENU_INDEX].item_count = 4;
  377   1          
  378   1          strcpy(menu_pages[ANGLE_PID_MENU_INDEX].items[0].name, "KP Value");
  379   1          menu_pages[ANGLE_PID_MENU_INDEX].items[0].function = function_angle_pid_setting;
  380   1          menu_pages[ANGLE_PID_MENU_INDEX].items[0].has_child = 0;
  381   1          
  382   1          strcpy(menu_pages[ANGLE_PID_MENU_INDEX].items[1].name, "KI Value");
  383   1          menu_pages[ANGLE_PID_MENU_INDEX].items[1].function = function_angle_pid_setting;
  384   1          menu_pages[ANGLE_PID_MENU_INDEX].items[1].has_child = 0;
  385   1          
  386   1          strcpy(menu_pages[ANGLE_PID_MENU_INDEX].items[2].name, "KD Value");
  387   1          menu_pages[ANGLE_PID_MENU_INDEX].items[2].function = function_angle_pid_setting;
C251 COMPILER V5.60.0,  menu                                                               12/06/25  20:23:03  PAGE 7   

  388   1          menu_pages[ANGLE_PID_MENU_INDEX].items[2].has_child = 0;
  389   1          
  390   1          strcpy(menu_pages[ANGLE_PID_MENU_INDEX].items[3].name, "Back");
  391   1          menu_pages[ANGLE_PID_MENU_INDEX].items[3].function = NULL;
  392   1          menu_pages[ANGLE_PID_MENU_INDEX].items[3].has_child = 0;
  393   1          
  394   1          // 初始化角度速度PID子菜单页
  395   1          strcpy(menu_pages[ANGLE_SPEED_PID_MENU_INDEX].title, "ANGLE SPEED PID");
  396   1          menu_pages[ANGLE_SPEED_PID_MENU_INDEX].item_count = 4;
  397   1          
  398   1          strcpy(menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[0].name, "KP Value");
  399   1          menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[0].function = function_angle_speed_pid_setting;
  400   1          menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[0].has_child = 0;
  401   1          
  402   1          strcpy(menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[1].name, "KI Value");
  403   1          menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[1].function = function_angle_speed_pid_setting;
  404   1          menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[1].has_child = 0;
  405   1          
  406   1          strcpy(menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[2].name, "KD Value");
  407   1          menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[2].function = function_angle_speed_pid_setting;
  408   1          menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[2].has_child = 0;
  409   1          
  410   1          strcpy(menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[3].name, "Back");
  411   1          menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[3].function = NULL;
  412   1          menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[3].has_child = 0;
  413   1          
  414   1          // 初始化左轮电机PID子菜单页
  415   1          strcpy(menu_pages[LEFT_MOTOR_PID_MENU_INDEX].title, "LEFT MOTOR PID");
  416   1          menu_pages[LEFT_MOTOR_PID_MENU_INDEX].item_count = 4;
  417   1          
  418   1          strcpy(menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[0].name, "KP Value");
  419   1          menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[0].function = function_left_motor_pid_setting;
  420   1          menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[0].has_child = 0;
  421   1          
  422   1          strcpy(menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[1].name, "KI Value");
  423   1          menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[1].function = function_left_motor_pid_setting;
  424   1          menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[1].has_child = 0;
  425   1          
  426   1          strcpy(menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[2].name, "KD Value");
  427   1          menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[2].function = function_left_motor_pid_setting;
  428   1          menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[2].has_child = 0;
  429   1          
  430   1          strcpy(menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[3].name, "Back");
  431   1          menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[3].function = NULL;
  432   1          menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[3].has_child = 0;
  433   1          
  434   1          // 初始化右轮电机PID子菜单页
  435   1          strcpy(menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].title, "RIGHT MOTOR PID");
  436   1          menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].item_count = 4;
  437   1          
  438   1          strcpy(menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[0].name, "KP Value");
  439   1          menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[0].function = function_right_motor_pid_setting;
  440   1          menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[0].has_child = 0;
  441   1          
  442   1          strcpy(menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[1].name, "KI Value");
  443   1          menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[1].function = function_right_motor_pid_setting;
  444   1          menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[1].has_child = 0;
  445   1          
  446   1          strcpy(menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[2].name, "KD Value");
  447   1          menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[2].function = function_right_motor_pid_setting;
  448   1          menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[2].has_child = 0;
  449   1          
  450   1          strcpy(menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[3].name, "Back");
  451   1          menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[3].function = NULL;
  452   1          menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[3].has_child = 0;
  453   1      
C251 COMPILER V5.60.0,  menu                                                               12/06/25  20:23:03  PAGE 8   

  454   1          // 初始化测试子菜单
  455   1          #if text_open
  456   1          strcpy(menu_pages[TEST_MENU_INDEX].title, "TESTS");
  457   1          menu_pages[TEST_MENU_INDEX].item_count = 8;  // 增加菜单项数
  458   1          
  459   1          strcpy(menu_pages[TEST_MENU_INDEX].items[0].name, "Key Test");
  460   1          menu_pages[TEST_MENU_INDEX].items[0].function = function_key_test;
  461   1          menu_pages[TEST_MENU_INDEX].items[0].has_child = 0;
  462   1          
  463   1          strcpy(menu_pages[TEST_MENU_INDEX].items[1].name, "ADC Test");
  464   1          menu_pages[TEST_MENU_INDEX].items[1].function = function_adc_test;
  465   1          menu_pages[TEST_MENU_INDEX].items[1].has_child = 0;
  466   1          
  467   1          strcpy(menu_pages[TEST_MENU_INDEX].items[2].name, "Encoder Test");
  468   1          menu_pages[TEST_MENU_INDEX].items[2].function = function_encoder_test;
  469   1          menu_pages[TEST_MENU_INDEX].items[2].has_child = 0;
  470   1      
  471   1          strcpy(menu_pages[TEST_MENU_INDEX].items[3].name, "IMU Test");
  472   1          menu_pages[TEST_MENU_INDEX].items[3].function = function_imu_test;
  473   1          menu_pages[TEST_MENU_INDEX].items[3].has_child = 0;
  474   1          
  475   1          strcpy(menu_pages[TEST_MENU_INDEX].items[4].name, "Buzzer Test");
  476   1          menu_pages[TEST_MENU_INDEX].items[4].function = function_buzzer_test;
  477   1          menu_pages[TEST_MENU_INDEX].items[4].has_child = 0;
  478   1          
  479   1          strcpy(menu_pages[TEST_MENU_INDEX].items[5].name, "UART Test");
  480   1          menu_pages[TEST_MENU_INDEX].items[5].function = function_uart_printf_test;
  481   1          menu_pages[TEST_MENU_INDEX].items[5].has_child = 0;
  482   1      
  483   1          strcpy(menu_pages[TEST_MENU_INDEX].items[6].name, "Path Test");
  484   1          menu_pages[TEST_MENU_INDEX].items[6].function = function_image_path_test;
  485   1          menu_pages[TEST_MENU_INDEX].items[6].has_child = 0;
  486   1      
  487   1          strcpy(menu_pages[TEST_MENU_INDEX].items[7].name, "inductance_max_min");
  488   1          menu_pages[TEST_MENU_INDEX].items[7].function = function_inductance_max_min_show;
  489   1          menu_pages[TEST_MENU_INDEX].items[7].has_child = 0;
  490   1          #endif
  491   1          #if game_open
                   // // 初始化游戏菜单页
                   strcpy(menu_pages[GAME_MENU_INDEX].title, "GAMES");
                   menu_pages[GAME_MENU_INDEX].item_count = 3;
                   
                   strcpy(menu_pages[GAME_MENU_INDEX].items[0].name, "Space Shooter");
                   menu_pages[GAME_MENU_INDEX].items[0].function = function_game;
                   menu_pages[GAME_MENU_INDEX].items[0].has_child = 0;
                   
                   strcpy(menu_pages[GAME_MENU_INDEX].items[1].name, "Snake Game");
                   menu_pages[GAME_MENU_INDEX].items[1].function = function_snake;
                   menu_pages[GAME_MENU_INDEX].items[1].has_child = 0;
                   
                   strcpy(menu_pages[GAME_MENU_INDEX].items[2].name, "Back");
                   menu_pages[GAME_MENU_INDEX].items[2].function = NULL;
                   menu_pages[GAME_MENU_INDEX].items[2].has_child = 0;
                   #endif
  508   1      }
  509          
  510          // 显示当前菜单
  511          void menu_display(void) {
  512   1          uint8 i;
  513   1          uint8 current_page_index = menu_state.current_page[menu_state.current_level];
  514   1          uint8 current_item_index = menu_state.current_index[menu_state.current_level];
  515   1          menu_page_t *current_page = &menu_pages[current_page_index];
  516   1          uint8 items_per_column = (current_page->item_count + 1) / 2;
  517   1          
  518   1          // 清屏
  519   1          ips200_clear(RGB565_WHITE);
C251 COMPILER V5.60.0,  menu                                                               12/06/25  20:23:03  PAGE 9   

  520   1          
  521   1          // 显示菜单标题
  522   1          ips200_show_string(10, 10, current_page->title);
  523   1          
  524   1          // 绘制分隔线
  525   1          for (i = 0; i < 38; i++) {  // 调整为38个"-"以适应320宽度
  526   2              ips200_show_string(10 + i * 8, 30, "-");
  527   2          }
  528   1          
  529   1          // 显示菜单项 - 两列布局
  530   1          for (i = 0; i < current_page->item_count; i++) {
  531   2              uint8 column = i / items_per_column;
  532   2              uint8 row = i % items_per_column;
  533   2              uint16 x_pos = 10 + (column * 140); // 两列布局
  534   2              uint16 y_pos = 50 + row * 30;
  535   2              
  536   2              if (i == current_item_index) {
  537   3                  ips200_set_color(RGB565_WHITE, RGB565_BLUE);
  538   3                  ips200_show_string(x_pos, y_pos, current_page->items[i].name);
  539   3                  ips200_set_color(RGB565_BLACK, RGB565_WHITE);
  540   3              } else {
  541   3                  ips200_show_string(x_pos, y_pos, current_page->items[i].name);
  542   3              }
  543   2              
  544   2              if (current_page->items[i].has_child) {
  545   3                  ips200_show_string(x_pos + 120, y_pos, ">");
  546   3              }
  547   2          }
  548   1          
  549   1          // 调整操作提示位置
  550   1          ips200_show_string(10, 220, "UP/DOWN:Navigate LEFT/RIGHT:Switch");
  551   1          ips200_show_string(10, 240, "OK:Select BACK:Return");
  552   1      }
  553          
  554          // 处理菜单按键输入
  555          void menu_process_buttons(void) {
  556   1          uint8 current_page_index = menu_state.current_page[menu_state.current_level];
  557   1          uint8 current_item_index = menu_state.current_index[menu_state.current_level];
  558   1          menu_page_t *current_page = &menu_pages[current_page_index];
  559   1          menu_item_t *current_item = &current_page->items[current_item_index];
  560   1          uint8 key_pressed = 0;  // 标记是否有按键处理
  561   1          uint8 items_per_column = (current_page->item_count + 1) / 2;
  562   1          
  563   1          // 上移选择
  564   1          if (button4) {
  565   2              if (current_item_index > 0) {
  566   3                  menu_state.current_index[menu_state.current_level]--;
  567   3                  menu_display();
  568   3              }
  569   2          }
  570   1          
  571   1          // 下移选择
  572   1          if (button3) {
  573   2              if (current_item_index < current_page->item_count - 1) {
  574   3                  menu_state.current_index[menu_state.current_level]++;
  575   3                  menu_display();
  576   3              }
  577   2          }
  578   1          
  579   1          // 左移选择 - 切换到左侧列
  580   1          if (button1) {
  581   2              if (current_item_index >= items_per_column) {
  582   3                  menu_state.current_index[menu_state.current_level] -= items_per_column;
  583   3                  menu_display();
  584   3              } else if (menu_state.current_level > 0) {
  585   3                  // 返回上级菜单
C251 COMPILER V5.60.0,  menu                                                               12/06/25  20:23:03  PAGE 10  

  586   3                  menu_state.current_level--;
  587   3                  menu_display();
  588   3              }
  589   2          }
  590   1          
  591   1          // 右移选择 - 切换到右侧列
  592   1          if (button2) {
  593   2              if (current_item_index + items_per_column < current_page->item_count) {
  594   3                  menu_state.current_index[menu_state.current_level] += items_per_column;
  595   3                  menu_display();
  596   3              }
  597   2          }
  598   1          
  599   1          
  600   1          // 确定按钮
  601   1          if (button5) {
  602   2              // 判断当前选中项是否为"Back"
  603   2              if (strcmp(current_item->name, "Back") == 0) {
  604   3                  // 返回上一级菜单
  605   3                  if (menu_state.current_level > 0) {
  606   4                      menu_state.current_level--;
  607   4                      menu_display();
  608   4                  }
  609   3              } 
  610   2              // 如果有子菜单，进入子菜单
  611   2              else if (current_item->has_child) {
  612   3                  menu_state.current_level++;
  613   3                  menu_state.current_page[menu_state.current_level] = current_item->child_index;
  614   3                  menu_state.current_index[menu_state.current_level] = 0;
  615   3                  menu_display();
  616   3              }
  617   2              // 如果有功能函数，执行功能
  618   2              else if (current_item->function != NULL) {
  619   3                  current_item->function();
  620   3                  menu_display();
  621   3              }
  622   2          }
  623   1      }
  624          
  625          // 菜单运行函数，放在主函数中
  626          void menu_run(void) {
  627   1          static uint8 last_button_status[5] = {0, 0, 0, 0, 0}; // 记录上一帧按键状态
  628   1          static uint8 one_into_flag = 1;
  629   1          if(one_into_flag)
  630   1          {
  631   2              one_into_flag = 0;
  632   2              menu_display();
  633   2          }
  634   1          
  635   1          // 检查按键状态是否已经处理过，如果已处理过就跳过
  636   1          if (button1 && !last_button_status[0]) {
  637   2              last_button_status[0] = 1;
  638   2          } else if (!button1 && last_button_status[0]) {
  639   2              last_button_status[0] = 0;
  640   2          } else if (button1) {
  641   2              button1 = 0; // 已经处理过，清除状态
  642   2          }
  643   1          
  644   1          if (button2 && !last_button_status[1]) {
  645   2              last_button_status[1] = 1;
  646   2          } else if (!button2 && last_button_status[1]) {
  647   2              last_button_status[1] = 0;
  648   2          } else if (button2) {
  649   2              button2 = 0; // 已经处理过，清除状态
  650   2          }
  651   1          
C251 COMPILER V5.60.0,  menu                                                               12/06/25  20:23:03  PAGE 11  

  652   1          if (button3 && !last_button_status[2]) {
  653   2              last_button_status[2] = 1;
  654   2          } else if (!button3 && last_button_status[2]) {
  655   2              last_button_status[2] = 0;
  656   2          } else if (button3) {
  657   2              button3 = 0; // 已经处理过，清除状态
  658   2          }
  659   1          
  660   1          if (button4 && !last_button_status[3]) {
  661   2              last_button_status[3] = 1;
  662   2          } else if (!button4 && last_button_status[3]) {
  663   2              last_button_status[3] = 0;
  664   2          } else if (button4) {
  665   2              button4 = 0; // 已经处理过，清除状态
  666   2          }
  667   1          
  668   1          if (button5 && !last_button_status[4]) {
  669   2              last_button_status[4] = 1;
  670   2          } else if (!button5 && last_button_status[4]) {
  671   2              last_button_status[4] = 0;
  672   2          } else if (button5) {
  673   2              button5 = 0; // 已经处理过，清除状态
  674   2          }
  675   1          
  676   1          // 处理按键动作
  677   1          if (button1) {
  678   2              // 按左键返回上级菜单
  679   2              if (menu_state.current_level > 0) {
  680   3                  menu_state.current_level--;
  681   3                  menu_display();
  682   3              }
  683   2          } else if (button3) {
  684   2              // 按下键选择下一菜单项
  685   2              if (menu_state.current_index[menu_state.current_level] < 
  686   2                  menu_pages[menu_state.current_page[menu_state.current_level]].item_count - 1) {
  687   3                  menu_state.current_index[menu_state.current_level]++;
  688   3                  menu_display();
  689   3              }
  690   2          } else if (button4) {
  691   2              // 按上键选择上一菜单项
  692   2              if (menu_state.current_index[menu_state.current_level] > 0) {
  693   3                  menu_state.current_index[menu_state.current_level]--;
  694   3                  menu_display();
  695   3              }
  696   2          } else if (button5) {
  697   2              // 按左键执行当前选中的菜单项
  698   2              menu_process_buttons();
  699   2          }
  700   1      }
  701          
  702          // ========== 示例功能函数实现 ==========
  703          
  704          // 空函数
  705          void function_dummy(void) {
  706   1          button5 = 0;
  707   1          // 清屏
  708   1          ips200_clear(RGB565_WHITE);
  709   1          ips200_show_string(10, 100, "Function Called");
  710   1          
  711   1          // 等待任意按键返回
  712   1          while(1) {
  713   2              if (button1 || button2 || button3 || button4 || button5) {
  714   3                  break;
  715   3              }
  716   2          }
  717   1      }
C251 COMPILER V5.60.0,  menu                                                               12/06/25  20:23:03  PAGE 12  

  718          
  719          // 速度设置功能
  720          void function_speed_setting(void) {
  721   1          uint8 exit_flag = 0;
  722   1          uint8 i;
  723   1          button5 = 0;
  724   1          
  725   1          // 清屏
  726   1          ips200_clear(RGB565_WHITE);
  727   1          ips200_show_string(10, 10, "SPEED SETTING");
  728   1          
  729   1          // 绘制分隔线
  730   1          for (i = 0; i < 30; i++) {
  731   2              ips200_show_string(10 + i * 8, 30, "-");
  732   2          }
  733   1          
  734   1          while (!exit_flag) {
  735   2              // 显示当前速度
  736   2              ips200_show_string(20, 60, "Current speed: ");
  737   2              ips200_show_int16(180, 60, speed_value);
  738   2              
  739   2              // 显示操作提示
  740   2              ips200_show_string(10, 200, "UP/DOWN: +/- value");
  741   2              ips200_show_string(10, 230, "LEFT: Return");
  742   2              button_entry();
  743   2              // 处理按键
  744   2              if (button4) {  // 上键增加
  745   3                  speed_value += 1;
  746   3              }
  747   2              
  748   2              if (button3) {  // 下键减少
  749   3                  speed_value -= 1;
  750   3              }
  751   2              
  752   2              if (button1) {  // 左键返回
  753   3                  exit_flag = 1;
  754   3              }
  755   2          }
  756   1      }
  757          
  758          // 角度PID参数设置功能
  759          void function_angle_pid_setting(void) {
  760   1          uint8 exit_flag = 0;
  761   1          float *current_value;
  762   1          char *param_name;
  763   1          uint8 current_page_index = menu_state.current_page[menu_state.current_level];
  764   1          uint8 current_item_index = menu_state.current_index[menu_state.current_level];
  765   1          uint8 i;
  766   1          char value_str[20]; // 用于格式化显示
  767   1          uint8 modified = 0; // 标记是否修改了参数
  768   1          button5 = 0;
  769   1          
  770   1          // 获取当前编辑的参数
  771   1          if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KP Value") == 0) {
  772   2              current_value = &PID_angle_P;
  773   2              param_name = "Angle KP";
  774   2          } else if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KI Value") == 0) {
  775   2              current_value = &PID_angle_I;
  776   2              param_name = "Angle KI";
  777   2          } else if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KD Value") == 0) {
  778   2              current_value = &PID_angle_D;
  779   2              param_name = "Angle KD";
  780   2          } else {
  781   2              return;
  782   2          }
  783   1          
C251 COMPILER V5.60.0,  menu                                                               12/06/25  20:23:03  PAGE 13  

  784   1          // 清屏
  785   1          ips200_clear(RGB565_WHITE);
  786   1          ips200_show_string(10, 10, "ANGLE PID SETTING");
  787   1          
  788   1          // 绘制分隔线
  789   1          for (i = 0; i < 30; i++) {
  790   2              ips200_show_string(10 + i * 8, 30, "-");
  791   2          }
  792   1          
  793   1          while (!exit_flag) {
  794   2              // 显示当前参数 - 使用字符串格式化
  795   2              ips200_show_string(20, 60, param_name);
  796   2              ips200_show_string(20, 90, "Value: ");
  797   2              
  798   2              // 格式化浮点数显示，避免显示问号
  799   2              sprintf(value_str, "%.2f", *current_value);
  800   2              ips200_show_string(100, 90, value_str);
  801   2              
  802   2              // 显示已修改
  803   2              if (modified) {
  804   3                  ips200_show_string(180, 90, "(Modified)");
  805   3              }
  806   2              
  807   2              // 显示操作提示
  808   2              ips200_show_string(10, 150, "UP: +0.1  DOWN: -0.1");
  809   2              ips200_show_string(10, 170, "RIGHT: +1.0  LEFT: -1.0");
  810   2              button_entry();
  811   2              // 处理按键
  812   2              if (button4) {  // 上键增加
  813   3                  (*current_value) += 0.1;
  814   3                  modified = 1;
  815   3              }
  816   2              
  817   2              if (button3) {  // 下键减少
  818   3                  (*current_value) -= 0.1;
  819   3                  modified = 1;
  820   3              }
  821   2              
  822   2              if (button2) {  // 右键大幅增加
  823   3                  (*current_value) += 1.0;
  824   3                  modified = 1;
  825   3              }
  826   2              
  827   2              if (button1) {  // 左键大幅减少
  828   3                  (*current_value) -= 1.0;
  829   3                  modified = 1;
  830   3              }
  831   2              
  832   2              if (button5) {  // 应用并返回
  833   3                  exit_flag = 1;
  834   3                  if (modified) {
  835   4                      // 应用参数到PID控制器
  836   4                      PidInit();
  837   4                      // 保存到EEPROM
  838   4                      eeprom_write();
  839   4                      
  840   4                      // 显示保存提示
  841   4                      ips200_clear(RGB565_WHITE);
  842   4                      ips200_show_string(50, 120, "Parameters Saved!");
  843   4                      system_delay_ms(500);
  844   4                  }
  845   3              }
  846   2              
  847   2              system_delay_ms(50);  // 减少延迟，提高响应速度
  848   2          }
  849   1      }
C251 COMPILER V5.60.0,  menu                                                               12/06/25  20:23:03  PAGE 14  

  850          
  851          // 角速度PID参数设置功能
  852          void function_angle_speed_pid_setting(void) {
  853   1          uint8 exit_flag = 0;
  854   1          float *current_value;
  855   1          char *param_name;
  856   1          uint8 current_page_index = menu_state.current_page[menu_state.current_level];
  857   1          uint8 current_item_index = menu_state.current_index[menu_state.current_level];
  858   1          uint8 i;
  859   1          char value_str[20]; // 用于格式化显示
  860   1          uint8 modified = 0; // 标记是否修改了参数
  861   1          button5 = 0;
  862   1          
  863   1          // 获取当前编辑的参数
  864   1          if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KP Value") == 0) {
  865   2              current_value = &PID_angle_speed_P;
  866   2              param_name = "Angle Speed KP";
  867   2          } else if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KI Value") == 0) {
  868   2              current_value = &PID_angle_speed_I;
  869   2              param_name = "Angle Speed KI";
  870   2          } else if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KD Value") == 0) {
  871   2              current_value = &PID_angle_speed_D;
  872   2              param_name = "Angle Speed KD";
  873   2          } else {
  874   2              return;
  875   2          }
  876   1          
  877   1          // 清屏
  878   1          ips200_clear(RGB565_WHITE);
  879   1          ips200_show_string(10, 10, "ANGLE SPEED PID SETTING");
  880   1          
  881   1          // 绘制分隔线
  882   1          for (i = 0; i < 30; i++) {
  883   2              ips200_show_string(10 + i * 8, 30, "-");
  884   2          }
  885   1          
  886   1          while (!exit_flag) {
  887   2              // 显示当前参数 - 使用字符串格式化
  888   2              ips200_show_string(20, 60, param_name);
  889   2              ips200_show_string(20, 90, "Value: ");
  890   2              
  891   2              // 格式化浮点数显示，避免显示问号
  892   2              sprintf(value_str, "%.2f", *current_value);
  893   2              ips200_show_string(100, 90, value_str);
  894   2              
  895   2              // 显示已修改
  896   2              if (modified) {
  897   3                  ips200_show_string(180, 90, "(Modified)");
  898   3              }
  899   2              
  900   2              // 显示操作提示
  901   2              ips200_show_string(10, 150, "UP: +0.1  DOWN: -0.1");
  902   2              ips200_show_string(10, 170, "RIGHT: +1.0  LEFT: -1.0");
  903   2              button_entry();
  904   2              // 处理按键
  905   2              if (button4) {  // 上键增加
  906   3                  (*current_value) += 0.1;
  907   3                  modified = 1;
  908   3              }
  909   2              
  910   2              if (button3) {  // 下键减少
  911   3                  (*current_value) -= 0.1;
  912   3                  modified = 1;
  913   3              }
  914   2              
  915   2              if (button2) {  // 右键大幅增加
C251 COMPILER V5.60.0,  menu                                                               12/06/25  20:23:03  PAGE 15  

  916   3                  (*current_value) += 1.0;
  917   3                  modified = 1;
  918   3              }
  919   2              
  920   2              if (button1) {  // 左键大幅减少
  921   3                  (*current_value) -= 1.0;
  922   3                  modified = 1;
  923   3              }
  924   2              
  925   2              if (button5) {  // 应用并返回
  926   3                  exit_flag = 1;
  927   3                  if (modified) {
  928   4                      // 应用参数到PID控制器
  929   4                      PidInit();
  930   4                      // 保存到EEPROM
  931   4                      eeprom_write();
  932   4                      
  933   4                      // 显示保存提示
  934   4                      ips200_clear(RGB565_WHITE);
  935   4                      ips200_show_string(50, 120, "Parameters Saved!");
  936   4                      system_delay_ms(500);
  937   4                  }
  938   3              }
  939   2              
  940   2              system_delay_ms(50);  // 减少延迟，提高响应速度
  941   2          }
  942   1      }
  943          
  944          // 左轮电机PID参数设置功能
  945          void function_left_motor_pid_setting(void) {
  946   1          uint8 exit_flag = 0;
  947   1          float *current_value;
  948   1          char *param_name;
  949   1          uint8 current_page_index = menu_state.current_page[menu_state.current_level];
  950   1          uint8 current_item_index = menu_state.current_index[menu_state.current_level];
  951   1          uint8 i;
  952   1          char value_str[20]; // 用于格式化显示
  953   1          uint8 modified = 0; // 标记是否修改了参数
  954   1          button5 = 0;
  955   1          
  956   1          // 获取当前编辑的参数
  957   1          if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KP Value") == 0) {
  958   2              current_value = &PID_MOTOR_L_P;
  959   2              param_name = "Left Motor KP";
  960   2          } else if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KI Value") == 0) {
  961   2              current_value = &PID_MOTOR_L_I;
  962   2              param_name = "Left Motor KI";
  963   2          } else if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KD Value") == 0) {
  964   2              current_value = &PID_MOTOR_L_D;
  965   2              param_name = "Left Motor KD";
  966   2          } else {
  967   2              return;
  968   2          }
  969   1          
  970   1          // 清屏
  971   1          ips200_clear(RGB565_WHITE);
  972   1          
  973   1          // 绘制分隔线
  974   1          for (i = 0; i < 30; i++) {
  975   2              ips200_show_string(10 + i * 8, 30, "-");
  976   2          }
  977   1          
  978   1          while (!exit_flag) {
  979   2              // 显示当前参数 - 使用字符串格式化
  980   2              ips200_show_string(20, 60, param_name);
  981   2              ips200_show_string(20, 90, "Value: ");
C251 COMPILER V5.60.0,  menu                                                               12/06/25  20:23:03  PAGE 16  

  982   2              
  983   2              // 格式化浮点数显示，避免显示问号
  984   2              sprintf(value_str, "%.4f", *current_value);
  985   2              ips200_show_string(100, 90, value_str);
  986   2              
  987   2              // 显示已修改
  988   2              if (modified) {
  989   3                  ips200_show_string(180, 90, "(Modified)");
  990   3              }
  991   2              
  992   2              // 显示操作提示
  993   2              ips200_show_string(10, 150, "UP: +0.01  DOWN: -0.01");
  994   2              ips200_show_string(10, 170, "RIGHT: +0.1  LEFT: -0.1");
  995   2              button_entry();
  996   2              // 处理按键
  997   2              if (button4) {  // 上键增加
  998   3                  (*current_value) += 0.01;
  999   3                  modified = 1;
 1000   3              }
 1001   2              
 1002   2              if (button3) {  // 下键减少
 1003   3                  (*current_value) -= 0.01;
 1004   3                  modified = 1;
 1005   3              }
 1006   2              
 1007   2              if (button2) {  // 右键大幅增加
 1008   3                  (*current_value) += 0.1;
 1009   3                  modified = 1;
 1010   3              }
 1011   2              
 1012   2              if (button1) {  // 左键大幅减少
 1013   3                  (*current_value) -= 0.1;
 1014   3                  modified = 1;
 1015   3              }
 1016   2              
 1017   2              if (button5) {  // 应用并返回
 1018   3                  exit_flag = 1;
 1019   3                  if (modified) {
 1020   4                      // 应用参数到PID控制器
 1021   4                      PidInit();
 1022   4                      // 保存到EEPROM
 1023   4                      eeprom_write();
 1024   4                      
 1025   4                      // 显示保存提示
 1026   4                      ips200_clear(RGB565_WHITE);
 1027   4                      ips200_show_string(50, 120, "Parameters Saved!");
 1028   4                      system_delay_ms(500);
 1029   4                  }
 1030   3              }
 1031   2              
 1032   2              system_delay_ms(50);  // 减少延迟，提高响应速度
 1033   2          }
 1034   1      }
 1035          
 1036          // 右轮电机PID参数设置功能
 1037          void function_right_motor_pid_setting(void) {
 1038   1          uint8 exit_flag = 0;
 1039   1          float *current_value;
 1040   1          char *param_name;
 1041   1          uint8 current_page_index = menu_state.current_page[menu_state.current_level];
 1042   1          uint8 current_item_index = menu_state.current_index[menu_state.current_level];
 1043   1          uint8 i;
 1044   1          char value_str[20]; // 用于格式化显示
 1045   1          uint8 modified = 0; // 标记是否修改了参数
 1046   1          button5 = 0;
 1047   1          
C251 COMPILER V5.60.0,  menu                                                               12/06/25  20:23:03  PAGE 17  

 1048   1          // 获取当前编辑的参数
 1049   1          if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KP Value") == 0) {
 1050   2              current_value = &PID_MOTOR_R_P;
 1051   2              param_name = "Right Motor KP";
 1052   2          } else if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KI Value") == 0) {
 1053   2              current_value = &PID_MOTOR_R_I;
 1054   2              param_name = "Right Motor KI";
 1055   2          } else if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KD Value") == 0) {
 1056   2              current_value = &PID_MOTOR_R_D;
 1057   2              param_name = "Right Motor KD";
 1058   2          } else {
 1059   2              return;
 1060   2          }
 1061   1          
 1062   1          // 清屏
 1063   1          ips200_clear(RGB565_WHITE);
 1064   1          ips200_show_string(10, 10, "RIGHT MOTOR PID SETTING");
 1065   1          
 1066   1          // 绘制分隔线
 1067   1          for (i = 0; i < 30; i++) {
 1068   2              ips200_show_string(10 + i * 8, 30, "-");
 1069   2          }
 1070   1          
 1071   1          while (!exit_flag) {
 1072   2              // 显示当前参数 - 使用字符串格式化
 1073   2              ips200_show_string(20, 60, param_name);
 1074   2              ips200_show_string(20, 90, "Value: ");
 1075   2              
 1076   2              // 格式化浮点数显示，避免显示问号
 1077   2              sprintf(value_str, "%.4f", *current_value);
 1078   2              ips200_show_string(100, 90, value_str);
 1079   2              
 1080   2              // 显示已修改
 1081   2              if (modified) {
 1082   3                  ips200_show_string(180, 90, "(Modified)");
 1083   3              }
 1084   2              
 1085   2              // 显示操作提示
 1086   2              ips200_show_string(10, 150, "UP: +0.01  DOWN: -0.01");
 1087   2              ips200_show_string(10, 170, "RIGHT: +0.1  LEFT: -0.1");
 1088   2              ips200_show_string(10, 190, "OK: Apply & Return");
 1089   2              button_entry();
 1090   2              // 处理按键
 1091   2              if (button4) {  // 上键增加
 1092   3                  (*current_value) += 0.01;
 1093   3                  modified = 1;
 1094   3              }
 1095   2              
 1096   2              if (button3) {  // 下键减少
 1097   3                  (*current_value) -= 0.01;
 1098   3                  modified = 1;
 1099   3              }
 1100   2              
 1101   2              if (button2) {  // 右键大幅增加
 1102   3                  (*current_value) += 0.1;
 1103   3                  modified = 1;
 1104   3              }
 1105   2              
 1106   2              if (button1) {  // 左键大幅减少
 1107   3                  (*current_value) -= 0.1;
 1108   3                  modified = 1;
 1109   3              }
 1110   2              
 1111   2              if (button5) {  // 应用并返回
 1112   3                  exit_flag = 1;
 1113   3                  if (modified) {
C251 COMPILER V5.60.0,  menu                                                               12/06/25  20:23:03  PAGE 18  

 1114   4                      // 应用参数到PID控制器
 1115   4                      PidInit();
 1116   4                      // 保存到EEPROM
 1117   4                      eeprom_write();
 1118   4                      
 1119   4                      // 显示保存提示
 1120   4                      ips200_clear(RGB565_WHITE);
 1121   4                      ips200_show_string(50, 120, "Parameters Saved!");
 1122   4                      system_delay_ms(500);
 1123   4                  }
 1124   3              }
 1125   2              
 1126   2              system_delay_ms(50);  // 减少延迟，提高响应速度
 1127   2          }
 1128   1      }
 1129          
 1130          // 传感器校准功能
 1131          void function_sensor_calibration(void) {
 1132   1          uint8 i;
 1133   1          button5 = 0;
 1134   1          
 1135   1          // 清屏
 1136   1          ips200_clear(RGB565_WHITE);
 1137   1          ips200_show_string(10, 10, "SENSOR CALIBRATION");
 1138   1          
 1139   1          // 绘制分隔线
 1140   1          for (i = 0; i < 30; i++) {
 1141   2              ips200_show_string(10 + i * 8, 30, "-");
 1142   2          }
 1143   1          
 1144   1          ips200_show_string(20, 90, "Please wait...");
 1145   1          
 1146   1          // 模拟校准过程
 1147   1          quaternion_init();
 1148   1          gyro_calibrate(200);
 1149   1          
 1150   1          ips200_show_string(20, 120, "Calibration complete!");
 1151   1          
 1152   1          // 等待任意按键返回
 1153   1          while(1) {
 1154   2              button_entry();
 1155   2              if (button1 || button2 || button3 || button4 || button5) {
 1156   3                  break;
 1157   3              }
 1158   2          }
 1159   1      }
 1160          
 1161          
 1162          // 添加重置PID参数功能
 1163          void function_reset_pid(void) {
 1164   1          uint8 exit_flag = 0;
 1165   1          uint8 confirm = 0;
 1166   1          uint8 i;
 1167   1          button5 = 0;
 1168   1          
 1169   1          // 清屏
 1170   1          ips200_clear(RGB565_WHITE);
 1171   1          ips200_show_string(10, 10, "RESET ALL PID PARAMETERS");
 1172   1          
 1173   1          // 绘制分隔线
 1174   1          for (i = 0; i < 30; i++) {
 1175   2              ips200_show_string(10 + i * 8, 30, "-");
 1176   2          }
 1177   1          
 1178   1          // 显示警告信息
 1179   1          ips200_show_string(20, 60, "Warning: This will reset");
C251 COMPILER V5.60.0,  menu                                                               12/06/25  20:23:03  PAGE 19  

 1180   1          ips200_show_string(20, 90, "all PID parameters!");
 1181   1          ips200_show_string(20, 120, "Are you sure?");
 1182   1          
 1183   1          while (!exit_flag) {
 1184   2              // 显示选项
 1185   2              if (confirm) {
 1186   3                  ips200_set_color(RGB565_WHITE, RGB565_RED);
 1187   3                  ips200_show_string(50, 160, "YES");
 1188   3                  ips200_set_color(RGB565_BLACK, RGB565_WHITE);
 1189   3                  ips200_show_string(150, 160, "NO");
 1190   3              } else {
 1191   3                  ips200_show_string(50, 160, "YES");
 1192   3                  ips200_set_color(RGB565_WHITE, RGB565_BLUE);
 1193   3                  ips200_show_string(150, 160, "NO");
 1194   3                  ips200_set_color(RGB565_BLACK, RGB565_WHITE);
 1195   3              }
 1196   2              
 1197   2              // 显示操作提示
 1198   2              ips200_show_string(10, 200, "LEFT/RIGHT: Select");
 1199   2              ips200_show_string(10, 230, "OK: Confirm");
 1200   2              button_entry();
 1201   2              // 处理按键
 1202   2              if (button1 || button2) {  // 左右键切换选项
 1203   3                  confirm = !confirm;
 1204   3              }
 1205   2              
 1206   2              if (button5) {  // 确定
 1207   3                  if (confirm) {
 1208   4                      // 执行重置操作
 1209   4                      eeprom_erase();
 1210   4                      
 1211   4                      // 重置所有PID参数
 1212   4                      // 角度环
 1213   4                      PID_angle_P = 0.0f;
 1214   4                      PID_angle_I = 0.0f;
 1215   4                      PID_angle_D = 0.0f;
 1216   4                      
 1217   4                      // 角速度环
 1218   4                      PID_angle_speed_P = 0.0f;
 1219   4                      PID_angle_speed_I = 0.0f;
 1220   4                      PID_angle_speed_D = 0.0f;
 1221   4                      
 1222   4                      // 左轮电机环
 1223   4                      PID_MOTOR_L_P = 0.0f;
 1224   4                      PID_MOTOR_L_I = 0.0f;
 1225   4                      PID_MOTOR_L_D = 0.0f;
 1226   4                      
 1227   4                      // 右轮电机环
 1228   4                      PID_MOTOR_R_P = 0.0f;
 1229   4                      PID_MOTOR_R_I = 0.0f;
 1230   4                      PID_MOTOR_R_D = 0.0f;
 1231   4                      
 1232   4                      // 应用重置后的参数
 1233   4                      PidInit();
 1234   4                      
 1235   4                      // 显示重置成功
 1236   4                      ips200_clear(RGB565_WHITE);
 1237   4                      ips200_show_string(50, 120, "Reset Successful!");
 1238   4                      system_delay_ms(1000);
 1239   4                  }
 1240   3                  exit_flag = 1;
 1241   3              }
 1242   2              
 1243   2              system_delay_ms(50);
 1244   2          }
 1245   1      }
C251 COMPILER V5.60.0,  menu                                                               12/06/25  20:23:03  PAGE 20  

 1246          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      8475     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =      3815     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =      1254     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
