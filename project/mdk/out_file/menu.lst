C251 COMPILER V5.60.0,  menu                                                               12/06/25  19:59:42  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE menu
OBJECT MODULE PLACED IN .\out_file\menu.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE ..\code\menu.c LARGE NOALIAS WARNINGLEVEL(3) OPTIMIZE(1,SIZE) BROWSE I
                    -NCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver;..\use
                    -r;..\code) DEBUG PRINT(.\out_file\menu.lst) TABS(2) OBJECT(.\out_file\menu.obj) 

stmt  level    source

    1          #include "zf_common_headfile.h"
    2          
    3          // 定义示例变量，这些变量可以在菜单功能中使用
    4          int16 speed_value = 0;
    5          uint8 seekfree_flag = 0;
    6          uint8 inductance_max_min_flag = 0;
    7          // 定义菜单
    8          menu_page_t menu_pages[17];
    9          
   10          // 菜单状态
   11          menu_state_t menu_state;
   12          
   13          // 主菜单页索引
   14          
   15          #define MAIN_MENU_INDEX 0
   16          
   17          
   18          // 声明测试函数
   19          extern void key_text(void);
   20          extern void adc_text(void);
   21          extern void encoder_text(void);
   22          extern void ips_text(void);
   23          extern void uart_printf_test(void);
   24          extern void quaternion_display(void);
   25          
   26          // 声明游戏函数
   27          // extern void function_game(void);
   28          // extern void function_snake(void);
   29          
   30          // 声明左右轮PID设置函数
   31          void function_left_motor_pid_setting(void);
   32          void function_right_motor_pid_setting(void);
   33          
   34          //开启逐飞传输
   35          void seekfree_assistant_open(void)
   36          {
   37   1          uint8 exit_flag = 0;
   38   1          seekfree_flag = !seekfree_flag;
   39   1          // 清屏
   40   1          ips200_clear(RGB565_WHITE);
   41   1          while (!exit_flag) {
   42   2          button_entry();
   43   2          ips200_show_string(100, 100, "Seekfree_flag");
   44   2          sprintf(txt, "%d", seekfree_flag);
   45   2          ips200_show_string(80, 120, txt);
   46   2          // 检测退出按键
   47   2          if (button5) {
   48   3              exit_flag = 1;
   49   3          }
   50   2          system_delay_ms(1);
   51   2          }
   52   1      }
   53          //开启电感最值判断
   54          void function_inductance_max_min_setting(void)
   55          {
   56   1          uint8 exit_flag = 0;
   57   1          inductance_max_min_flag = !inductance_max_min_flag;
C251 COMPILER V5.60.0,  menu                                                               12/06/25  19:59:42  PAGE 2   

   58   1          // 清屏
   59   1          ips200_clear(RGB565_WHITE);
   60   1          while (!exit_flag) {
   61   2          button_entry();
   62   2          inductance_judgment();
   63   2          // 检测退出按键
   64   2          if (button5) {
   65   3              exit_flag = 1;
   66   3          }
   67   2          system_delay_ms(1);
   68   2          }
   69   1          eeprom_write_inductance_max_min();
   70   1      }
   71          
   72          #if text_open //测试功能封装函数
   73          // 测试功能封装函数
   74          //开启电感最值显示
   75          void function_inductance_max_min_show(void)
   76          {
   77   1          uint8 exit_flag = 0;
   78   1          // 清屏
   79   1          ips200_clear(RGB565_WHITE);
   80   1          
   81   1          while (!exit_flag) {
   82   2              // 显示电感最大值
   83   2              sprintf(txt, "H1_max: %.2f", inductance_horizontal_1_max);
   84   2              ips200_show_string(0, 0, txt);
   85   2              
   86   2              sprintf(txt, "V2_max: %.2f", inductance_vertical_2_max);
   87   2              ips200_show_string(0, 16, txt);
   88   2              
   89   2              sprintf(txt, "V3_max: %.2f", inductance_vertical_3_max);
   90   2              ips200_show_string(0, 32, txt);
   91   2              
   92   2              sprintf(txt, "H4_max: %.2f", inductance_horizontal_4_max);
   93   2              ips200_show_string(0, 48, txt);
   94   2              
   95   2              // 显示电感最小值
   96   2              sprintf(txt, "H1_min: %.2f", inductance_horizontal_1_min);
   97   2              ips200_show_string(0, 80, txt);
   98   2              
   99   2              sprintf(txt, "V2_min: %.2f", inductance_vertical_2_min);
  100   2              ips200_show_string(0, 96, txt);
  101   2              
  102   2              sprintf(txt, "V3_min: %.2f", inductance_vertical_3_min);
  103   2              ips200_show_string(0, 112, txt);
  104   2              
  105   2              sprintf(txt, "H4_min: %.2f", inductance_horizontal_4_min);
  106   2              ips200_show_string(0, 128, txt);
  107   2              
  108   2              // 检测按键
  109   2              button_entry();
  110   2              if (button5) {
  111   3                  exit_flag = 1;
  112   3              }
  113   2              
  114   2              // 延时刷新
  115   2              system_delay_ms(100);
  116   2          }
  117   1      }
  118          void function_key_test(void) {
  119   1          uint8 exit_flag = 0;
  120   1          button5 = 0;
  121   1          
  122   1          // 清屏
  123   1          ips200_clear(RGB565_WHITE);
C251 COMPILER V5.60.0,  menu                                                               12/06/25  19:59:42  PAGE 3   

  124   1          while (!exit_flag) {
  125   2              button_entry();
  126   2              // 调用按键测试函数
  127   2              key_text();
  128   2              
  129   2              // 检测退出按键
  130   2              if (button5) {
  131   3                  exit_flag = 1;
  132   3              }
  133   2              system_delay_ms(10);
  134   2          }
  135   1      }
  136          void function_imu_test(void) {
  137   1          uint8 exit_flag = 0;
  138   1          button5 = 0;
  139   1          
  140   1          // 清屏
  141   1          ips200_clear(RGB565_WHITE);
  142   1          while (!exit_flag) {
  143   2              button_entry();
  144   2              // 调用IMU测试函数
  145   2              quaternion_display();
  146   2              // imu660ra_text();
  147   2              // 检测退出按键
  148   2              if (button5) {
  149   3                  exit_flag = 1;
  150   3              }
  151   2              system_delay_ms(5);
  152   2          }
  153   1      }       
  154          void function_uart_printf_test(void) {
  155   1          uint8 exit_flag = 0;
  156   1          button5 = 0;
  157   1          
  158   1          // 清屏
  159   1          ips200_clear(RGB565_WHITE);
  160   1      
  161   1          while (!exit_flag) {
  162   2              button_entry();
  163   2              // 调用UART测试函数
  164   2              uart_printf_test(); 
  165   2              
  166   2              // 检测退出按键
  167   2              if (button5) {
  168   3                  exit_flag = 1;
  169   3              }   
  170   2              system_delay_ms(10);
  171   2          }
  172   1      }
  173          
  174          
  175          void function_adc_test(void) {
  176   1          uint8 exit_flag = 0;
  177   1          button5 = 0;
  178   1          
  179   1          // 清屏
  180   1          ips200_clear(RGB565_WHITE);
  181   1          
  182   1          while (!exit_flag) {
  183   2              button_entry();
  184   2              // 调用ADC测试函数
  185   2              adc_main_read();
  186   2              // inductance_normalization_max();
  187   2              inductance_difference_ratio_sum();
  188   2              adc_text();
  189   2              
C251 COMPILER V5.60.0,  menu                                                               12/06/25  19:59:42  PAGE 4   

  190   2              // 检测退出按键
  191   2              if (button5) {
  192   3                  exit_flag = 1;
  193   3              }
  194   2              system_delay_ms(10);
  195   2          }
  196   1      }
  197          
  198          void function_encoder_test(void) {
  199   1          uint8 exit_flag = 0;
  200   1          button5 = 0;
  201   1          
  202   1          // 清屏
  203   1          ips200_clear(RGB565_WHITE);
  204   1          
  205   1          while (!exit_flag) {
  206   2              button_entry();
  207   2              // 调用编码器测试函数
  208   2              encoder_text();
  209   2              
  210   2              // 检测退出按键
  211   2              if (button5) {
  212   3                  exit_flag = 1;
  213   3              }
  214   2              system_delay_ms(10);
  215   2          }
  216   1      }
  217          
  218          void function_ips_test(void) {
  219   1          uint8 exit_flag = 0;
  220   1          button5 = 0;
  221   1          
  222   1          // 清屏
  223   1          ips200_clear(RGB565_WHITE);
  224   1          
  225   1          while (!exit_flag) {
  226   2              button_entry();
  227   2              // 调用IPS显示测试函数
  228   2              ips_text();
  229   2              
  230   2              // 检测退出按键
  231   2              if (button5) {
  232   3                  exit_flag = 1;
  233   3              }
  234   2              system_delay_ms(10);
  235   2          }
  236   1      }
  237          void function_buzzer_test(void) {
  238   1          uint8 exit_flag = 0;
  239   1          button5 = 0;
  240   1          
  241   1          // 清屏
  242   1          ips200_clear(RGB565_WHITE);
  243   1          
  244   1          while (!exit_flag) {
  245   2              button_entry();
  246   2              // 调用蜂鸣器测试函数
  247   2              buzzer_time(100);
  248   2              
  249   2              // 检测退出按键 
  250   2              if (button5) {
  251   3                  exit_flag = 1;
  252   3              }
  253   2              system_delay_ms(10);
  254   2          }
  255   1      }  
C251 COMPILER V5.60.0,  menu                                                               12/06/25  19:59:42  PAGE 5   

  256          // 添加 image_path 测试函数
  257          void function_image_path_test(void) {
  258   1          uint8 exit_flag = 0;
  259   1          button5 = 0;
  260   1          
  261   1          // 清屏
  262   1          ips200_clear(RGB565_WHITE);
  263   1          
  264   1          while (!exit_flag) {
  265   2              button_entry();
  266   2              #if image_open
                       // 调用路径绘制函数
                       image_path();
                       // 检测退出按键
                       #endif
  271   2              if (button5) {
  272   3                  exit_flag = 1;
  273   3              }
  274   2              system_delay_ms(5);
  275   2          }
  276   1      }
  277          #endif
  278          // 初始化菜单系统
  279          void menu_init(void) {
  280   1          // 初始化菜单状态
  281   1          menu_state.current_level = 0;
  282   1          menu_state.current_page[0] = MAIN_MENU_INDEX;
  283   1          menu_state.current_index[0] = 0;
  284   1          
  285   1          // 初始化主菜单
  286   1          strcpy(menu_pages[MAIN_MENU_INDEX].title, "MAIN MENU");
  287   1          menu_pages[MAIN_MENU_INDEX].item_count = 7; // 增加菜单项数
  288   1          
  289   1          // 设置主菜单项
  290   1          strcpy(menu_pages[MAIN_MENU_INDEX].items[0].name, "Settings");
  291   1          menu_pages[MAIN_MENU_INDEX].items[0].function = NULL;
  292   1          menu_pages[MAIN_MENU_INDEX].items[0].has_child = 1;
  293   1          menu_pages[MAIN_MENU_INDEX].items[0].child_index = SETTING_MENU_INDEX;
  294   1          
  295   1          strcpy(menu_pages[MAIN_MENU_INDEX].items[1].name, "PID Parameters");
  296   1          menu_pages[MAIN_MENU_INDEX].items[1].function = NULL;
  297   1          menu_pages[MAIN_MENU_INDEX].items[1].has_child = 1;
  298   1          menu_pages[MAIN_MENU_INDEX].items[1].child_index = PID_MENU_INDEX;
  299   1          
  300   1          strcpy(menu_pages[MAIN_MENU_INDEX].items[2].name, "Tests");
  301   1          menu_pages[MAIN_MENU_INDEX].items[2].function = NULL;
  302   1          menu_pages[MAIN_MENU_INDEX].items[2].has_child = 1;
  303   1          menu_pages[MAIN_MENU_INDEX].items[2].child_index = TEST_MENU_INDEX;
  304   1          
  305   1          strcpy(menu_pages[MAIN_MENU_INDEX].items[3].name, "Calibration");
  306   1          menu_pages[MAIN_MENU_INDEX].items[3].function = function_sensor_calibration;
  307   1          menu_pages[MAIN_MENU_INDEX].items[3].has_child = 0;
  308   1          
  309   1           // 添加游戏菜单
  310   1          //  strcpy(menu_pages[MAIN_MENU_INDEX].items[4].name, "Games");
  311   1          //  menu_pages[MAIN_MENU_INDEX].items[5].function = NULL;
  312   1          //  menu_pages[MAIN_MENU_INDEX].items[5].has_child = 1;
  313   1          // menu_pages[MAIN_MENU_INDEX].items[5].child_index = GAME_MENU_INDEX;
  314   1      
  315   1          strcpy(menu_pages[MAIN_MENU_INDEX].items[4].name, "Seekfree");
  316   1          menu_pages[MAIN_MENU_INDEX].items[4].function = seekfree_assistant_open;
  317   1          menu_pages[MAIN_MENU_INDEX].items[4].has_child = 0;
  318   1      
  319   1          strcpy(menu_pages[MAIN_MENU_INDEX].items[5].name, "Inductance Max Min");
  320   1          menu_pages[MAIN_MENU_INDEX].items[5].function = function_inductance_max_min_setting;
  321   1          menu_pages[MAIN_MENU_INDEX].items[5].has_child = 0;
C251 COMPILER V5.60.0,  menu                                                               12/06/25  19:59:42  PAGE 6   

  322   1          
  323   1          // 初始化子菜单
  324   1          strcpy(menu_pages[SETTING_MENU_INDEX].title, "SETTINGS");
  325   1          menu_pages[SETTING_MENU_INDEX].item_count = 3;
  326   1          
  327   1          strcpy(menu_pages[SETTING_MENU_INDEX].items[0].name, "Speed");
  328   1          menu_pages[SETTING_MENU_INDEX].items[0].function = function_speed_setting;
  329   1          menu_pages[SETTING_MENU_INDEX].items[0].has_child = 0;
  330   1          
  331   1          strcpy(menu_pages[SETTING_MENU_INDEX].items[1].name, "Display Mode");
  332   1          menu_pages[SETTING_MENU_INDEX].items[1].function = function_dummy;
  333   1          menu_pages[SETTING_MENU_INDEX].items[1].has_child = 0;
  334   1          
  335   1          strcpy(menu_pages[SETTING_MENU_INDEX].items[2].name, "Back");
  336   1          menu_pages[SETTING_MENU_INDEX].items[2].function = NULL;
  337   1          menu_pages[SETTING_MENU_INDEX].items[2].has_child = 0;
  338   1          
  339   1          // 初始化PID子菜单页
  340   1          strcpy(menu_pages[PID_MENU_INDEX].title, "PID PARAMETERS");
  341   1          menu_pages[PID_MENU_INDEX].item_count = 6;  // 增加菜单项数
  342   1          
  343   1          strcpy(menu_pages[PID_MENU_INDEX].items[0].name, "Angle PID");
  344   1          menu_pages[PID_MENU_INDEX].items[0].function = NULL;
  345   1          menu_pages[PID_MENU_INDEX].items[0].has_child = 1;
  346   1          menu_pages[PID_MENU_INDEX].items[0].child_index = ANGLE_PID_MENU_INDEX;
  347   1          
  348   1          strcpy(menu_pages[PID_MENU_INDEX].items[1].name, "Angle Speed PID");
  349   1          menu_pages[PID_MENU_INDEX].items[1].function = NULL;
  350   1          menu_pages[PID_MENU_INDEX].items[1].has_child = 1;
  351   1          menu_pages[PID_MENU_INDEX].items[1].child_index = ANGLE_SPEED_PID_MENU_INDEX;
  352   1          
  353   1          strcpy(menu_pages[PID_MENU_INDEX].items[2].name, "Left Motor PID");
  354   1          menu_pages[PID_MENU_INDEX].items[2].function = NULL;
  355   1          menu_pages[PID_MENU_INDEX].items[2].has_child = 1;
  356   1          menu_pages[PID_MENU_INDEX].items[2].child_index = LEFT_MOTOR_PID_MENU_INDEX;
  357   1      
  358   1          strcpy(menu_pages[PID_MENU_INDEX].items[3].name, "Right Motor PID");
  359   1          menu_pages[PID_MENU_INDEX].items[3].function = NULL;
  360   1          menu_pages[PID_MENU_INDEX].items[3].has_child = 1;
  361   1          menu_pages[PID_MENU_INDEX].items[3].child_index = RIGHT_MOTOR_PID_MENU_INDEX;
  362   1          
  363   1          // 添加重置PID参数选项
  364   1          strcpy(menu_pages[PID_MENU_INDEX].items[4].name, "Reset All PID");
  365   1          menu_pages[PID_MENU_INDEX].items[4].function = function_reset_pid;
  366   1          menu_pages[PID_MENU_INDEX].items[4].has_child = 0;
  367   1          
  368   1          strcpy(menu_pages[PID_MENU_INDEX].items[5].name, "Back");
  369   1          menu_pages[PID_MENU_INDEX].items[5].function = NULL;
  370   1          menu_pages[PID_MENU_INDEX].items[5].has_child = 0;
  371   1          
  372   1          // 初始化角度PID子菜单页
  373   1          strcpy(menu_pages[ANGLE_PID_MENU_INDEX].title, "ANGLE PID");
  374   1          menu_pages[ANGLE_PID_MENU_INDEX].item_count = 4;
  375   1          
  376   1          strcpy(menu_pages[ANGLE_PID_MENU_INDEX].items[0].name, "KP Value");
  377   1          menu_pages[ANGLE_PID_MENU_INDEX].items[0].function = function_angle_pid_setting;
  378   1          menu_pages[ANGLE_PID_MENU_INDEX].items[0].has_child = 0;
  379   1          
  380   1          strcpy(menu_pages[ANGLE_PID_MENU_INDEX].items[1].name, "KI Value");
  381   1          menu_pages[ANGLE_PID_MENU_INDEX].items[1].function = function_angle_pid_setting;
  382   1          menu_pages[ANGLE_PID_MENU_INDEX].items[1].has_child = 0;
  383   1          
  384   1          strcpy(menu_pages[ANGLE_PID_MENU_INDEX].items[2].name, "KD Value");
  385   1          menu_pages[ANGLE_PID_MENU_INDEX].items[2].function = function_angle_pid_setting;
  386   1          menu_pages[ANGLE_PID_MENU_INDEX].items[2].has_child = 0;
  387   1          
C251 COMPILER V5.60.0,  menu                                                               12/06/25  19:59:42  PAGE 7   

  388   1          strcpy(menu_pages[ANGLE_PID_MENU_INDEX].items[3].name, "Back");
  389   1          menu_pages[ANGLE_PID_MENU_INDEX].items[3].function = NULL;
  390   1          menu_pages[ANGLE_PID_MENU_INDEX].items[3].has_child = 0;
  391   1          
  392   1          // 初始化角度速度PID子菜单页
  393   1          strcpy(menu_pages[ANGLE_SPEED_PID_MENU_INDEX].title, "ANGLE SPEED PID");
  394   1          menu_pages[ANGLE_SPEED_PID_MENU_INDEX].item_count = 4;
  395   1          
  396   1          strcpy(menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[0].name, "KP Value");
  397   1          menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[0].function = function_angle_speed_pid_setting;
  398   1          menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[0].has_child = 0;
  399   1          
  400   1          strcpy(menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[1].name, "KI Value");
  401   1          menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[1].function = function_angle_speed_pid_setting;
  402   1          menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[1].has_child = 0;
  403   1          
  404   1          strcpy(menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[2].name, "KD Value");
  405   1          menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[2].function = function_angle_speed_pid_setting;
  406   1          menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[2].has_child = 0;
  407   1          
  408   1          strcpy(menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[3].name, "Back");
  409   1          menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[3].function = NULL;
  410   1          menu_pages[ANGLE_SPEED_PID_MENU_INDEX].items[3].has_child = 0;
  411   1          
  412   1          // 初始化左轮电机PID子菜单页
  413   1          strcpy(menu_pages[LEFT_MOTOR_PID_MENU_INDEX].title, "LEFT MOTOR PID");
  414   1          menu_pages[LEFT_MOTOR_PID_MENU_INDEX].item_count = 4;
  415   1          
  416   1          strcpy(menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[0].name, "KP Value");
  417   1          menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[0].function = function_left_motor_pid_setting;
  418   1          menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[0].has_child = 0;
  419   1          
  420   1          strcpy(menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[1].name, "KI Value");
  421   1          menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[1].function = function_left_motor_pid_setting;
  422   1          menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[1].has_child = 0;
  423   1          
  424   1          strcpy(menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[2].name, "KD Value");
  425   1          menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[2].function = function_left_motor_pid_setting;
  426   1          menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[2].has_child = 0;
  427   1          
  428   1          strcpy(menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[3].name, "Back");
  429   1          menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[3].function = NULL;
  430   1          menu_pages[LEFT_MOTOR_PID_MENU_INDEX].items[3].has_child = 0;
  431   1          
  432   1          // 初始化右轮电机PID子菜单页
  433   1          strcpy(menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].title, "RIGHT MOTOR PID");
  434   1          menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].item_count = 4;
  435   1          
  436   1          strcpy(menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[0].name, "KP Value");
  437   1          menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[0].function = function_right_motor_pid_setting;
  438   1          menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[0].has_child = 0;
  439   1          
  440   1          strcpy(menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[1].name, "KI Value");
  441   1          menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[1].function = function_right_motor_pid_setting;
  442   1          menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[1].has_child = 0;
  443   1          
  444   1          strcpy(menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[2].name, "KD Value");
  445   1          menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[2].function = function_right_motor_pid_setting;
  446   1          menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[2].has_child = 0;
  447   1          
  448   1          strcpy(menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[3].name, "Back");
  449   1          menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[3].function = NULL;
  450   1          menu_pages[RIGHT_MOTOR_PID_MENU_INDEX].items[3].has_child = 0;
  451   1      
  452   1          // 初始化测试子菜单
  453   1          #if text_open
C251 COMPILER V5.60.0,  menu                                                               12/06/25  19:59:42  PAGE 8   

  454   1          strcpy(menu_pages[TEST_MENU_INDEX].title, "TESTS");
  455   1          menu_pages[TEST_MENU_INDEX].item_count = 8;  // 增加菜单项数
  456   1          
  457   1          strcpy(menu_pages[TEST_MENU_INDEX].items[0].name, "Key Test");
  458   1          menu_pages[TEST_MENU_INDEX].items[0].function = function_key_test;
  459   1          menu_pages[TEST_MENU_INDEX].items[0].has_child = 0;
  460   1          
  461   1          strcpy(menu_pages[TEST_MENU_INDEX].items[1].name, "ADC Test");
  462   1          menu_pages[TEST_MENU_INDEX].items[1].function = function_adc_test;
  463   1          menu_pages[TEST_MENU_INDEX].items[1].has_child = 0;
  464   1          
  465   1          strcpy(menu_pages[TEST_MENU_INDEX].items[2].name, "Encoder Test");
  466   1          menu_pages[TEST_MENU_INDEX].items[2].function = function_encoder_test;
  467   1          menu_pages[TEST_MENU_INDEX].items[2].has_child = 0;
  468   1      
  469   1          strcpy(menu_pages[TEST_MENU_INDEX].items[3].name, "IMU Test");
  470   1          menu_pages[TEST_MENU_INDEX].items[3].function = function_imu_test;
  471   1          menu_pages[TEST_MENU_INDEX].items[3].has_child = 0;
  472   1          
  473   1          strcpy(menu_pages[TEST_MENU_INDEX].items[4].name, "Buzzer Test");
  474   1          menu_pages[TEST_MENU_INDEX].items[4].function = function_buzzer_test;
  475   1          menu_pages[TEST_MENU_INDEX].items[4].has_child = 0;
  476   1          
  477   1          strcpy(menu_pages[TEST_MENU_INDEX].items[5].name, "UART Test");
  478   1          menu_pages[TEST_MENU_INDEX].items[5].function = function_uart_printf_test;
  479   1          menu_pages[TEST_MENU_INDEX].items[5].has_child = 0;
  480   1      
  481   1          strcpy(menu_pages[TEST_MENU_INDEX].items[6].name, "Path Test");
  482   1          menu_pages[TEST_MENU_INDEX].items[6].function = function_image_path_test;
  483   1          menu_pages[TEST_MENU_INDEX].items[6].has_child = 0;
  484   1      
  485   1          strcpy(menu_pages[TEST_MENU_INDEX].items[7].name, "inductance_max_min");
  486   1          menu_pages[TEST_MENU_INDEX].items[7].function = function_inductance_max_min_show;
  487   1          menu_pages[TEST_MENU_INDEX].items[7].has_child = 0;
  488   1          #endif
  489   1          // // 初始化游戏菜单页
  490   1          // strcpy(menu_pages[GAME_MENU_INDEX].title, "GAMES");
  491   1          // menu_pages[GAME_MENU_INDEX].item_count = 3;
  492   1          
  493   1          // strcpy(menu_pages[GAME_MENU_INDEX].items[0].name, "Space Shooter");
  494   1          // menu_pages[GAME_MENU_INDEX].items[0].function = function_game;
  495   1          // menu_pages[GAME_MENU_INDEX].items[0].has_child = 0;
  496   1          
  497   1          // strcpy(menu_pages[GAME_MENU_INDEX].items[1].name, "Snake Game");
  498   1          // menu_pages[GAME_MENU_INDEX].items[1].function = function_snake;
  499   1          // menu_pages[GAME_MENU_INDEX].items[1].has_child = 0;
  500   1          
  501   1          // strcpy(menu_pages[GAME_MENU_INDEX].items[2].name, "Back");
  502   1          // menu_pages[GAME_MENU_INDEX].items[2].function = NULL;
  503   1          // menu_pages[GAME_MENU_INDEX].items[2].has_child = 0;
  504   1      }
  505          
  506          // 显示当前菜单
  507          void menu_display(void) {
  508   1          uint8 i;
  509   1          uint8 current_page_index = menu_state.current_page[menu_state.current_level];
  510   1          uint8 current_item_index = menu_state.current_index[menu_state.current_level];
  511   1          menu_page_t *current_page = &menu_pages[current_page_index];
  512   1          uint8 items_per_column = (current_page->item_count + 1) / 2;
  513   1          
  514   1          // 清屏
  515   1          ips200_clear(RGB565_WHITE);
  516   1          
  517   1          // 显示菜单标题
  518   1          ips200_show_string(10, 10, current_page->title);
  519   1          
C251 COMPILER V5.60.0,  menu                                                               12/06/25  19:59:42  PAGE 9   

  520   1          // 绘制分隔线
  521   1          for (i = 0; i < 38; i++) {  // 调整为38个"-"以适应320宽度
  522   2              ips200_show_string(10 + i * 8, 30, "-");
  523   2          }
  524   1          
  525   1          // 显示菜单项 - 两列布局
  526   1          for (i = 0; i < current_page->item_count; i++) {
  527   2              uint8 column = i / items_per_column;
  528   2              uint8 row = i % items_per_column;
  529   2              uint16 x_pos = 10 + (column * 140); // 两列布局
  530   2              uint16 y_pos = 50 + row * 30;
  531   2              
  532   2              if (i == current_item_index) {
  533   3                  ips200_set_color(RGB565_WHITE, RGB565_BLUE);
  534   3                  ips200_show_string(x_pos, y_pos, current_page->items[i].name);
  535   3                  ips200_set_color(RGB565_BLACK, RGB565_WHITE);
  536   3              } else {
  537   3                  ips200_show_string(x_pos, y_pos, current_page->items[i].name);
  538   3              }
  539   2              
  540   2              if (current_page->items[i].has_child) {
  541   3                  ips200_show_string(x_pos + 120, y_pos, ">");
  542   3              }
  543   2          }
  544   1          
  545   1          // 调整操作提示位置
  546   1          ips200_show_string(10, 220, "UP/DOWN:Navigate LEFT/RIGHT:Switch");
  547   1          ips200_show_string(10, 240, "OK:Select BACK:Return");
  548   1      }
  549          
  550          // 处理菜单按键输入
  551          void menu_process_buttons(void) {
  552   1          uint8 current_page_index = menu_state.current_page[menu_state.current_level];
  553   1          uint8 current_item_index = menu_state.current_index[menu_state.current_level];
  554   1          menu_page_t *current_page = &menu_pages[current_page_index];
  555   1          menu_item_t *current_item = &current_page->items[current_item_index];
  556   1          uint8 key_pressed = 0;  // 标记是否有按键处理
  557   1          uint8 items_per_column = (current_page->item_count + 1) / 2;
  558   1          
  559   1          // 上移选择
  560   1          if (button4) {
  561   2              if (current_item_index > 0) {
  562   3                  menu_state.current_index[menu_state.current_level]--;
  563   3                  menu_display();
  564   3              }
  565   2          }
  566   1          
  567   1          // 下移选择
  568   1          if (button3) {
  569   2              if (current_item_index < current_page->item_count - 1) {
  570   3                  menu_state.current_index[menu_state.current_level]++;
  571   3                  menu_display();
  572   3              }
  573   2          }
  574   1          
  575   1          // 左移选择 - 切换到左侧列
  576   1          if (button1) {
  577   2              if (current_item_index >= items_per_column) {
  578   3                  menu_state.current_index[menu_state.current_level] -= items_per_column;
  579   3                  menu_display();
  580   3              } else if (menu_state.current_level > 0) {
  581   3                  // 返回上级菜单
  582   3                  menu_state.current_level--;
  583   3                  menu_display();
  584   3              }
  585   2          }
C251 COMPILER V5.60.0,  menu                                                               12/06/25  19:59:42  PAGE 10  

  586   1          
  587   1          // 右移选择 - 切换到右侧列
  588   1          if (button2) {
  589   2              if (current_item_index + items_per_column < current_page->item_count) {
  590   3                  menu_state.current_index[menu_state.current_level] += items_per_column;
  591   3                  menu_display();
  592   3              }
  593   2          }
  594   1          
  595   1          
  596   1          // 确定按钮
  597   1          if (button5) {
  598   2              // 判断当前选中项是否为"Back"
  599   2              if (strcmp(current_item->name, "Back") == 0) {
  600   3                  // 返回上一级菜单
  601   3                  if (menu_state.current_level > 0) {
  602   4                      menu_state.current_level--;
  603   4                      menu_display();
  604   4                  }
  605   3              } 
  606   2              // 如果有子菜单，进入子菜单
  607   2              else if (current_item->has_child) {
  608   3                  menu_state.current_level++;
  609   3                  menu_state.current_page[menu_state.current_level] = current_item->child_index;
  610   3                  menu_state.current_index[menu_state.current_level] = 0;
  611   3                  menu_display();
  612   3              }
  613   2              // 如果有功能函数，执行功能
  614   2              else if (current_item->function != NULL) {
  615   3                  current_item->function();
  616   3                  menu_display();
  617   3              }
  618   2          }
  619   1      }
  620          
  621          // 菜单运行函数，放在主函数中
  622          void menu_run(void) {
  623   1          static uint8 last_button_status[5] = {0, 0, 0, 0, 0}; // 记录上一帧按键状态
  624   1          static uint8 one_into_flag = 1;
  625   1          if(one_into_flag)
  626   1          {
  627   2              one_into_flag = 0;
  628   2              menu_display();
  629   2          }
  630   1          
  631   1          // 检查按键状态是否已经处理过，如果已处理过就跳过
  632   1          if (button1 && !last_button_status[0]) {
  633   2              last_button_status[0] = 1;
  634   2          } else if (!button1 && last_button_status[0]) {
  635   2              last_button_status[0] = 0;
  636   2          } else if (button1) {
  637   2              button1 = 0; // 已经处理过，清除状态
  638   2          }
  639   1          
  640   1          if (button2 && !last_button_status[1]) {
  641   2              last_button_status[1] = 1;
  642   2          } else if (!button2 && last_button_status[1]) {
  643   2              last_button_status[1] = 0;
  644   2          } else if (button2) {
  645   2              button2 = 0; // 已经处理过，清除状态
  646   2          }
  647   1          
  648   1          if (button3 && !last_button_status[2]) {
  649   2              last_button_status[2] = 1;
  650   2          } else if (!button3 && last_button_status[2]) {
  651   2              last_button_status[2] = 0;
C251 COMPILER V5.60.0,  menu                                                               12/06/25  19:59:42  PAGE 11  

  652   2          } else if (button3) {
  653   2              button3 = 0; // 已经处理过，清除状态
  654   2          }
  655   1          
  656   1          if (button4 && !last_button_status[3]) {
  657   2              last_button_status[3] = 1;
  658   2          } else if (!button4 && last_button_status[3]) {
  659   2              last_button_status[3] = 0;
  660   2          } else if (button4) {
  661   2              button4 = 0; // 已经处理过，清除状态
  662   2          }
  663   1          
  664   1          if (button5 && !last_button_status[4]) {
  665   2              last_button_status[4] = 1;
  666   2          } else if (!button5 && last_button_status[4]) {
  667   2              last_button_status[4] = 0;
  668   2          } else if (button5) {
  669   2              button5 = 0; // 已经处理过，清除状态
  670   2          }
  671   1          
  672   1          // 处理按键动作
  673   1          if (button1) {
  674   2              // 按左键返回上级菜单
  675   2              if (menu_state.current_level > 0) {
  676   3                  menu_state.current_level--;
  677   3                  menu_display();
  678   3              }
  679   2          } else if (button3) {
  680   2              // 按下键选择下一菜单项
  681   2              if (menu_state.current_index[menu_state.current_level] < 
  682   2                  menu_pages[menu_state.current_page[menu_state.current_level]].item_count - 1) {
  683   3                  menu_state.current_index[menu_state.current_level]++;
  684   3                  menu_display();
  685   3              }
  686   2          } else if (button4) {
  687   2              // 按上键选择上一菜单项
  688   2              if (menu_state.current_index[menu_state.current_level] > 0) {
  689   3                  menu_state.current_index[menu_state.current_level]--;
  690   3                  menu_display();
  691   3              }
  692   2          } else if (button5) {
  693   2              // 按左键执行当前选中的菜单项
  694   2              menu_process_buttons();
  695   2          }
  696   1      }
  697          
  698          // ========== 示例功能函数实现 ==========
  699          
  700          // 空函数
  701          void function_dummy(void) {
  702   1          button5 = 0;
  703   1          // 清屏
  704   1          ips200_clear(RGB565_WHITE);
  705   1          ips200_show_string(10, 100, "Function Called");
  706   1          
  707   1          // 等待任意按键返回
  708   1          while(1) {
  709   2              if (button1 || button2 || button3 || button4 || button5) {
  710   3                  break;
  711   3              }
  712   2          }
  713   1      }
  714          
  715          // 速度设置功能
  716          void function_speed_setting(void) {
  717   1          uint8 exit_flag = 0;
C251 COMPILER V5.60.0,  menu                                                               12/06/25  19:59:42  PAGE 12  

  718   1          uint8 i;
  719   1          button5 = 0;
  720   1          
  721   1          // 清屏
  722   1          ips200_clear(RGB565_WHITE);
  723   1          ips200_show_string(10, 10, "SPEED SETTING");
  724   1          
  725   1          // 绘制分隔线
  726   1          for (i = 0; i < 30; i++) {
  727   2              ips200_show_string(10 + i * 8, 30, "-");
  728   2          }
  729   1          
  730   1          while (!exit_flag) {
  731   2              // 显示当前速度
  732   2              ips200_show_string(20, 60, "Current speed: ");
  733   2              ips200_show_int16(180, 60, speed_value);
  734   2              
  735   2              // 显示操作提示
  736   2              ips200_show_string(10, 200, "UP/DOWN: +/- value");
  737   2              ips200_show_string(10, 230, "LEFT: Return");
  738   2              button_entry();
  739   2              // 处理按键
  740   2              if (button4) {  // 上键增加
  741   3                  speed_value += 1;
  742   3              }
  743   2              
  744   2              if (button3) {  // 下键减少
  745   3                  speed_value -= 1;
  746   3              }
  747   2              
  748   2              if (button1) {  // 左键返回
  749   3                  exit_flag = 1;
  750   3              }
  751   2          }
  752   1      }
  753          
  754          // 角度PID参数设置功能
  755          void function_angle_pid_setting(void) {
  756   1          uint8 exit_flag = 0;
  757   1          float *current_value;
  758   1          char *param_name;
  759   1          uint8 current_page_index = menu_state.current_page[menu_state.current_level];
  760   1          uint8 current_item_index = menu_state.current_index[menu_state.current_level];
  761   1          uint8 i;
  762   1          char value_str[20]; // 用于格式化显示
  763   1          uint8 modified = 0; // 标记是否修改了参数
  764   1          button5 = 0;
  765   1          
  766   1          // 获取当前编辑的参数
  767   1          if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KP Value") == 0) {
  768   2              current_value = &PID_angle_P;
  769   2              param_name = "Angle KP";
  770   2          } else if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KI Value") == 0) {
  771   2              current_value = &PID_angle_I;
  772   2              param_name = "Angle KI";
  773   2          } else if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KD Value") == 0) {
  774   2              current_value = &PID_angle_D;
  775   2              param_name = "Angle KD";
  776   2          } else {
  777   2              return;
  778   2          }
  779   1          
  780   1          // 清屏
  781   1          ips200_clear(RGB565_WHITE);
  782   1          ips200_show_string(10, 10, "ANGLE PID SETTING");
  783   1          
C251 COMPILER V5.60.0,  menu                                                               12/06/25  19:59:42  PAGE 13  

  784   1          // 绘制分隔线
  785   1          for (i = 0; i < 30; i++) {
  786   2              ips200_show_string(10 + i * 8, 30, "-");
  787   2          }
  788   1          
  789   1          while (!exit_flag) {
  790   2              // 显示当前参数 - 使用字符串格式化
  791   2              ips200_show_string(20, 60, param_name);
  792   2              ips200_show_string(20, 90, "Value: ");
  793   2              
  794   2              // 格式化浮点数显示，避免显示问号
  795   2              sprintf(value_str, "%.2f", *current_value);
  796   2              ips200_show_string(100, 90, value_str);
  797   2              
  798   2              // 显示已修改
  799   2              if (modified) {
  800   3                  ips200_show_string(180, 90, "(Modified)");
  801   3              }
  802   2              
  803   2              // 显示操作提示
  804   2              ips200_show_string(10, 150, "UP: +0.1  DOWN: -0.1");
  805   2              ips200_show_string(10, 170, "RIGHT: +1.0  LEFT: -1.0");
  806   2              button_entry();
  807   2              // 处理按键
  808   2              if (button4) {  // 上键增加
  809   3                  (*current_value) += 0.1;
  810   3                  modified = 1;
  811   3              }
  812   2              
  813   2              if (button3) {  // 下键减少
  814   3                  (*current_value) -= 0.1;
  815   3                  modified = 1;
  816   3              }
  817   2              
  818   2              if (button2) {  // 右键大幅增加
  819   3                  (*current_value) += 1.0;
  820   3                  modified = 1;
  821   3              }
  822   2              
  823   2              if (button1) {  // 左键大幅减少
  824   3                  (*current_value) -= 1.0;
  825   3                  modified = 1;
  826   3              }
  827   2              
  828   2              if (button5) {  // 应用并返回
  829   3                  exit_flag = 1;
  830   3                  if (modified) {
  831   4                      // 应用参数到PID控制器
  832   4                      PidInit();
  833   4                      // 保存到EEPROM
  834   4                      eeprom_write();
  835   4                      
  836   4                      // 显示保存提示
  837   4                      ips200_clear(RGB565_WHITE);
  838   4                      ips200_show_string(50, 120, "Parameters Saved!");
  839   4                      system_delay_ms(500);
  840   4                  }
  841   3              }
  842   2              
  843   2              system_delay_ms(50);  // 减少延迟，提高响应速度
  844   2          }
  845   1      }
  846          
  847          // 角速度PID参数设置功能
  848          void function_angle_speed_pid_setting(void) {
  849   1          uint8 exit_flag = 0;
C251 COMPILER V5.60.0,  menu                                                               12/06/25  19:59:42  PAGE 14  

  850   1          float *current_value;
  851   1          char *param_name;
  852   1          uint8 current_page_index = menu_state.current_page[menu_state.current_level];
  853   1          uint8 current_item_index = menu_state.current_index[menu_state.current_level];
  854   1          uint8 i;
  855   1          char value_str[20]; // 用于格式化显示
  856   1          uint8 modified = 0; // 标记是否修改了参数
  857   1          button5 = 0;
  858   1          
  859   1          // 获取当前编辑的参数
  860   1          if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KP Value") == 0) {
  861   2              current_value = &PID_angle_speed_P;
  862   2              param_name = "Angle Speed KP";
  863   2          } else if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KI Value") == 0) {
  864   2              current_value = &PID_angle_speed_I;
  865   2              param_name = "Angle Speed KI";
  866   2          } else if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KD Value") == 0) {
  867   2              current_value = &PID_angle_speed_D;
  868   2              param_name = "Angle Speed KD";
  869   2          } else {
  870   2              return;
  871   2          }
  872   1          
  873   1          // 清屏
  874   1          ips200_clear(RGB565_WHITE);
  875   1          ips200_show_string(10, 10, "ANGLE SPEED PID SETTING");
  876   1          
  877   1          // 绘制分隔线
  878   1          for (i = 0; i < 30; i++) {
  879   2              ips200_show_string(10 + i * 8, 30, "-");
  880   2          }
  881   1          
  882   1          while (!exit_flag) {
  883   2              // 显示当前参数 - 使用字符串格式化
  884   2              ips200_show_string(20, 60, param_name);
  885   2              ips200_show_string(20, 90, "Value: ");
  886   2              
  887   2              // 格式化浮点数显示，避免显示问号
  888   2              sprintf(value_str, "%.2f", *current_value);
  889   2              ips200_show_string(100, 90, value_str);
  890   2              
  891   2              // 显示已修改
  892   2              if (modified) {
  893   3                  ips200_show_string(180, 90, "(Modified)");
  894   3              }
  895   2              
  896   2              // 显示操作提示
  897   2              ips200_show_string(10, 150, "UP: +0.1  DOWN: -0.1");
  898   2              ips200_show_string(10, 170, "RIGHT: +1.0  LEFT: -1.0");
  899   2              button_entry();
  900   2              // 处理按键
  901   2              if (button4) {  // 上键增加
  902   3                  (*current_value) += 0.1;
  903   3                  modified = 1;
  904   3              }
  905   2              
  906   2              if (button3) {  // 下键减少
  907   3                  (*current_value) -= 0.1;
  908   3                  modified = 1;
  909   3              }
  910   2              
  911   2              if (button2) {  // 右键大幅增加
  912   3                  (*current_value) += 1.0;
  913   3                  modified = 1;
  914   3              }
  915   2              
C251 COMPILER V5.60.0,  menu                                                               12/06/25  19:59:42  PAGE 15  

  916   2              if (button1) {  // 左键大幅减少
  917   3                  (*current_value) -= 1.0;
  918   3                  modified = 1;
  919   3              }
  920   2              
  921   2              if (button5) {  // 应用并返回
  922   3                  exit_flag = 1;
  923   3                  if (modified) {
  924   4                      // 应用参数到PID控制器
  925   4                      PidInit();
  926   4                      // 保存到EEPROM
  927   4                      eeprom_write();
  928   4                      
  929   4                      // 显示保存提示
  930   4                      ips200_clear(RGB565_WHITE);
  931   4                      ips200_show_string(50, 120, "Parameters Saved!");
  932   4                      system_delay_ms(500);
  933   4                  }
  934   3              }
  935   2              
  936   2              system_delay_ms(50);  // 减少延迟，提高响应速度
  937   2          }
  938   1      }
  939          
  940          // 左轮电机PID参数设置功能
  941          void function_left_motor_pid_setting(void) {
  942   1          uint8 exit_flag = 0;
  943   1          float *current_value;
  944   1          char *param_name;
  945   1          uint8 current_page_index = menu_state.current_page[menu_state.current_level];
  946   1          uint8 current_item_index = menu_state.current_index[menu_state.current_level];
  947   1          uint8 i;
  948   1          char value_str[20]; // 用于格式化显示
  949   1          uint8 modified = 0; // 标记是否修改了参数
  950   1          button5 = 0;
  951   1          
  952   1          // 获取当前编辑的参数
  953   1          if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KP Value") == 0) {
  954   2              current_value = &PID_MOTOR_L_P;
  955   2              param_name = "Left Motor KP";
  956   2          } else if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KI Value") == 0) {
  957   2              current_value = &PID_MOTOR_L_I;
  958   2              param_name = "Left Motor KI";
  959   2          } else if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KD Value") == 0) {
  960   2              current_value = &PID_MOTOR_L_D;
  961   2              param_name = "Left Motor KD";
  962   2          } else {
  963   2              return;
  964   2          }
  965   1          
  966   1          // 清屏
  967   1          ips200_clear(RGB565_WHITE);
  968   1          
  969   1          // 绘制分隔线
  970   1          for (i = 0; i < 30; i++) {
  971   2              ips200_show_string(10 + i * 8, 30, "-");
  972   2          }
  973   1          
  974   1          while (!exit_flag) {
  975   2              // 显示当前参数 - 使用字符串格式化
  976   2              ips200_show_string(20, 60, param_name);
  977   2              ips200_show_string(20, 90, "Value: ");
  978   2              
  979   2              // 格式化浮点数显示，避免显示问号
  980   2              sprintf(value_str, "%.4f", *current_value);
  981   2              ips200_show_string(100, 90, value_str);
C251 COMPILER V5.60.0,  menu                                                               12/06/25  19:59:42  PAGE 16  

  982   2              
  983   2              // 显示已修改
  984   2              if (modified) {
  985   3                  ips200_show_string(180, 90, "(Modified)");
  986   3              }
  987   2              
  988   2              // 显示操作提示
  989   2              ips200_show_string(10, 150, "UP: +0.01  DOWN: -0.01");
  990   2              ips200_show_string(10, 170, "RIGHT: +0.1  LEFT: -0.1");
  991   2              button_entry();
  992   2              // 处理按键
  993   2              if (button4) {  // 上键增加
  994   3                  (*current_value) += 0.01;
  995   3                  modified = 1;
  996   3              }
  997   2              
  998   2              if (button3) {  // 下键减少
  999   3                  (*current_value) -= 0.01;
 1000   3                  modified = 1;
 1001   3              }
 1002   2              
 1003   2              if (button2) {  // 右键大幅增加
 1004   3                  (*current_value) += 0.1;
 1005   3                  modified = 1;
 1006   3              }
 1007   2              
 1008   2              if (button1) {  // 左键大幅减少
 1009   3                  (*current_value) -= 0.1;
 1010   3                  modified = 1;
 1011   3              }
 1012   2              
 1013   2              if (button5) {  // 应用并返回
 1014   3                  exit_flag = 1;
 1015   3                  if (modified) {
 1016   4                      // 应用参数到PID控制器
 1017   4                      PidInit();
 1018   4                      // 保存到EEPROM
 1019   4                      eeprom_write();
 1020   4                      
 1021   4                      // 显示保存提示
 1022   4                      ips200_clear(RGB565_WHITE);
 1023   4                      ips200_show_string(50, 120, "Parameters Saved!");
 1024   4                      system_delay_ms(500);
 1025   4                  }
 1026   3              }
 1027   2              
 1028   2              system_delay_ms(50);  // 减少延迟，提高响应速度
 1029   2          }
 1030   1      }
 1031          
 1032          // 右轮电机PID参数设置功能
 1033          void function_right_motor_pid_setting(void) {
 1034   1          uint8 exit_flag = 0;
 1035   1          float *current_value;
 1036   1          char *param_name;
 1037   1          uint8 current_page_index = menu_state.current_page[menu_state.current_level];
 1038   1          uint8 current_item_index = menu_state.current_index[menu_state.current_level];
 1039   1          uint8 i;
 1040   1          char value_str[20]; // 用于格式化显示
 1041   1          uint8 modified = 0; // 标记是否修改了参数
 1042   1          button5 = 0;
 1043   1          
 1044   1          // 获取当前编辑的参数
 1045   1          if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KP Value") == 0) {
 1046   2              current_value = &PID_MOTOR_R_P;
 1047   2              param_name = "Right Motor KP";
C251 COMPILER V5.60.0,  menu                                                               12/06/25  19:59:42  PAGE 17  

 1048   2          } else if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KI Value") == 0) {
 1049   2              current_value = &PID_MOTOR_R_I;
 1050   2              param_name = "Right Motor KI";
 1051   2          } else if (strcmp(menu_pages[current_page_index].items[current_item_index].name, "KD Value") == 0) {
 1052   2              current_value = &PID_MOTOR_R_D;
 1053   2              param_name = "Right Motor KD";
 1054   2          } else {
 1055   2              return;
 1056   2          }
 1057   1          
 1058   1          // 清屏
 1059   1          ips200_clear(RGB565_WHITE);
 1060   1          ips200_show_string(10, 10, "RIGHT MOTOR PID SETTING");
 1061   1          
 1062   1          // 绘制分隔线
 1063   1          for (i = 0; i < 30; i++) {
 1064   2              ips200_show_string(10 + i * 8, 30, "-");
 1065   2          }
 1066   1          
 1067   1          while (!exit_flag) {
 1068   2              // 显示当前参数 - 使用字符串格式化
 1069   2              ips200_show_string(20, 60, param_name);
 1070   2              ips200_show_string(20, 90, "Value: ");
 1071   2              
 1072   2              // 格式化浮点数显示，避免显示问号
 1073   2              sprintf(value_str, "%.4f", *current_value);
 1074   2              ips200_show_string(100, 90, value_str);
 1075   2              
 1076   2              // 显示已修改
 1077   2              if (modified) {
 1078   3                  ips200_show_string(180, 90, "(Modified)");
 1079   3              }
 1080   2              
 1081   2              // 显示操作提示
 1082   2              ips200_show_string(10, 150, "UP: +0.01  DOWN: -0.01");
 1083   2              ips200_show_string(10, 170, "RIGHT: +0.1  LEFT: -0.1");
 1084   2              ips200_show_string(10, 190, "OK: Apply & Return");
 1085   2              button_entry();
 1086   2              // 处理按键
 1087   2              if (button4) {  // 上键增加
 1088   3                  (*current_value) += 0.01;
 1089   3                  modified = 1;
 1090   3              }
 1091   2              
 1092   2              if (button3) {  // 下键减少
 1093   3                  (*current_value) -= 0.01;
 1094   3                  modified = 1;
 1095   3              }
 1096   2              
 1097   2              if (button2) {  // 右键大幅增加
 1098   3                  (*current_value) += 0.1;
 1099   3                  modified = 1;
 1100   3              }
 1101   2              
 1102   2              if (button1) {  // 左键大幅减少
 1103   3                  (*current_value) -= 0.1;
 1104   3                  modified = 1;
 1105   3              }
 1106   2              
 1107   2              if (button5) {  // 应用并返回
 1108   3                  exit_flag = 1;
 1109   3                  if (modified) {
 1110   4                      // 应用参数到PID控制器
 1111   4                      PidInit();
 1112   4                      // 保存到EEPROM
 1113   4                      eeprom_write();
C251 COMPILER V5.60.0,  menu                                                               12/06/25  19:59:42  PAGE 18  

 1114   4                      
 1115   4                      // 显示保存提示
 1116   4                      ips200_clear(RGB565_WHITE);
 1117   4                      ips200_show_string(50, 120, "Parameters Saved!");
 1118   4                      system_delay_ms(500);
 1119   4                  }
 1120   3              }
 1121   2              
 1122   2              system_delay_ms(50);  // 减少延迟，提高响应速度
 1123   2          }
 1124   1      }
 1125          
 1126          // 传感器校准功能
 1127          void function_sensor_calibration(void) {
 1128   1          uint8 i;
 1129   1          button5 = 0;
 1130   1          
 1131   1          // 清屏
 1132   1          ips200_clear(RGB565_WHITE);
 1133   1          ips200_show_string(10, 10, "SENSOR CALIBRATION");
 1134   1          
 1135   1          // 绘制分隔线
 1136   1          for (i = 0; i < 30; i++) {
 1137   2              ips200_show_string(10 + i * 8, 30, "-");
 1138   2          }
 1139   1          
 1140   1          ips200_show_string(20, 90, "Please wait...");
 1141   1          
 1142   1          // 模拟校准过程
 1143   1          quaternion_init();
 1144   1          gyro_calibrate(200);
 1145   1          
 1146   1          ips200_show_string(20, 120, "Calibration complete!");
 1147   1          
 1148   1          // 等待任意按键返回
 1149   1          while(1) {
 1150   2              button_entry();
 1151   2              if (button1 || button2 || button3 || button4 || button5) {
 1152   3                  break;
 1153   3              }
 1154   2          }
 1155   1      }
 1156          
 1157          
 1158          // 添加重置PID参数功能
 1159          void function_reset_pid(void) {
 1160   1          uint8 exit_flag = 0;
 1161   1          uint8 confirm = 0;
 1162   1          uint8 i;
 1163   1          button5 = 0;
 1164   1          
 1165   1          // 清屏
 1166   1          ips200_clear(RGB565_WHITE);
 1167   1          ips200_show_string(10, 10, "RESET ALL PID PARAMETERS");
 1168   1          
 1169   1          // 绘制分隔线
 1170   1          for (i = 0; i < 30; i++) {
 1171   2              ips200_show_string(10 + i * 8, 30, "-");
 1172   2          }
 1173   1          
 1174   1          // 显示警告信息
 1175   1          ips200_show_string(20, 60, "Warning: This will reset");
 1176   1          ips200_show_string(20, 90, "all PID parameters!");
 1177   1          ips200_show_string(20, 120, "Are you sure?");
 1178   1          
 1179   1          while (!exit_flag) {
C251 COMPILER V5.60.0,  menu                                                               12/06/25  19:59:42  PAGE 19  

 1180   2              // 显示选项
 1181   2              if (confirm) {
 1182   3                  ips200_set_color(RGB565_WHITE, RGB565_RED);
 1183   3                  ips200_show_string(50, 160, "YES");
 1184   3                  ips200_set_color(RGB565_BLACK, RGB565_WHITE);
 1185   3                  ips200_show_string(150, 160, "NO");
 1186   3              } else {
 1187   3                  ips200_show_string(50, 160, "YES");
 1188   3                  ips200_set_color(RGB565_WHITE, RGB565_BLUE);
 1189   3                  ips200_show_string(150, 160, "NO");
 1190   3                  ips200_set_color(RGB565_BLACK, RGB565_WHITE);
 1191   3              }
 1192   2              
 1193   2              // 显示操作提示
 1194   2              ips200_show_string(10, 200, "LEFT/RIGHT: Select");
 1195   2              ips200_show_string(10, 230, "OK: Confirm");
 1196   2              button_entry();
 1197   2              // 处理按键
 1198   2              if (button1 || button2) {  // 左右键切换选项
 1199   3                  confirm = !confirm;
 1200   3              }
 1201   2              
 1202   2              if (button5) {  // 确定
 1203   3                  if (confirm) {
 1204   4                      // 执行重置操作
 1205   4                      eeprom_erase();
 1206   4                      
 1207   4                      // 重置所有PID参数
 1208   4                      // 角度环
 1209   4                      PID_angle_P = 0.0f;
 1210   4                      PID_angle_I = 0.0f;
 1211   4                      PID_angle_D = 0.0f;
 1212   4                      
 1213   4                      // 角速度环
 1214   4                      PID_angle_speed_P = 0.0f;
 1215   4                      PID_angle_speed_I = 0.0f;
 1216   4                      PID_angle_speed_D = 0.0f;
 1217   4                      
 1218   4                      // 左轮电机环
 1219   4                      PID_MOTOR_L_P = 0.0f;
 1220   4                      PID_MOTOR_L_I = 0.0f;
 1221   4                      PID_MOTOR_L_D = 0.0f;
 1222   4                      
 1223   4                      // 右轮电机环
 1224   4                      PID_MOTOR_R_P = 0.0f;
 1225   4                      PID_MOTOR_R_I = 0.0f;
 1226   4                      PID_MOTOR_R_D = 0.0f;
 1227   4                      
 1228   4                      // 应用重置后的参数
 1229   4                      PidInit();
 1230   4                      
 1231   4                      // 显示重置成功
 1232   4                      ips200_clear(RGB565_WHITE);
 1233   4                      ips200_show_string(50, 120, "Reset Successful!");
 1234   4                      system_delay_ms(1000);
 1235   4                  }
 1236   3                  exit_flag = 1;
 1237   3              }
 1238   2              
 1239   2              system_delay_ms(50);
 1240   2          }
 1241   1      }
 1242          


Module Information          Static   Overlayable
------------------------------------------------
C251 COMPILER V5.60.0,  menu                                                               12/06/25  19:59:42  PAGE 20  

  code size            =      8475     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =      3815     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =      1254     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
