C251 COMPILER V5.60.0,  IMU                                                                15/06/25  00:02:59  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE IMU
OBJECT MODULE PLACED IN .\out_file\IMU.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE ..\code\IMU.c LARGE NOALIAS WARNINGLEVEL(3) OPTIMIZE(1,SIZE) BROWSE IN
                    -CDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver;..\user
                    -;..\code) DEBUG PRINT(.\out_file\IMU.lst) TABS(2) OBJECT(.\out_file\IMU.obj) 

stmt  level    source

    1          #include "zf_common_headfile.h"
    2          
    3          /* å…¨å±€å˜é‡å®šä¹‰ */
    4          imu_data_t imu_data;                           /* IMUæ•°æ® */
    5          Quaternion q = {1.0f, 0.0f, 0.0f, 0.0f};       /* å››å…ƒæ•°ï¼Œåˆå§‹åŒ–ä¸ºå•ä½å››å…ƒæ•° */
    6          EulerAngle euler = {0.0f, 0.0f, 0.0f};         /* æ¬§æ‹‰è§’ */
    7          float encoder_file[1000];
    8          uint16 encoder_ins_num = 0;      /*insæ€»è®¡æ•°*/
    9          uint8 ins_go_flag = 0;          /*inså‘è½¦ä½*/
   10          uint8 encoder_ins_memory_flag=0; /*æƒ¯æ€§å¯¼èˆªå­˜å‚¨æ ‡å¿—ä½*/
   11          #ifdef text_open
   12          //-------------------------------------------------------------------------------------------------------
             -------------
   13          // å‡½æ•°ç®€ä»‹     IMUæ•°æ®æ˜¾ç¤ºå‡½æ•°ï¼Œç”¨äºåœ¨IPSå±å¹•ä¸Šæ˜¾ç¤ºIMUçš„åŠ é€Ÿåº¦å’Œé™€èºä»ªæ•°æ®
   14          // å‚æ•°è¯´æ˜     void
   15          // è¿”å›å‚æ•°     void
   16          // ä½¿ç”¨ç¤ºä¾‹     imu660ra_text();
   17          //-------------------------------------------------------------------------------------------------------
             -------------
   18          void imu660ra_text(void)
   19          {   
   20   1          /* è·å–IMU660RAæ•°æ® */
   21   1          imu660ra_get_acc();
   22   1          imu660ra_get_gyro();
   23   1          /* åœ¨IPSæ˜¾ç¤ºå™¨ä¸Šæ˜¾ç¤ºåŠ é€Ÿåº¦æ•°æ® */
   24   1          ips200_show_string(0, 16, "acc_x: ");
   25   1          ips200_show_int16(60, 16, imu660ra_acc_x);
   26   1          
   27   1          ips200_show_string(0, 32, "acc_y: ");
   28   1          ips200_show_int16(60, 32, imu660ra_acc_y);
   29   1          
   30   1          ips200_show_string(0, 48, "acc_z: ");
   31   1          ips200_show_int16(60, 48, imu660ra_acc_z);
   32   1          
   33   1          /* åœ¨IPSæ˜¾ç¤ºå™¨ä¸Šæ˜¾ç¤ºé™€èºä»ªæ•°æ® */
   34   1          ips200_show_string(0, 70, "IMU660RA Gyroscope:");
   35   1          ips200_show_string(0, 86, "gyro_x: ");
   36   1          ips200_show_int16(60, 86, imu660ra_gyro_x);
   37   1          
   38   1          ips200_show_string(0, 102, "gyro_y: ");
   39   1          ips200_show_int16(60, 102, imu660ra_gyro_y);
   40   1          
   41   1          ips200_show_string(0, 118, "gyro_z: ");
   42   1          ips200_show_int16(60, 118, imu660ra_gyro_z);
   43   1          
   44   1          /* çŸ­æš‚å»¶æ—¶ï¼Œä½¿æ˜¾ç¤ºæ›´ç¨³å®š */
   45   1          system_delay_ms(100);
   46   1      }
   47          #endif
   48          
   49          //-------------------------------------------------------------------------------------------------------
             -------------
   50          // å‡½æ•°ç®€ä»‹     å››å…ƒæ•°åˆå§‹åŒ–å‡½æ•°ï¼Œç”¨äºåˆå§‹åŒ–å››å…ƒæ•°å’Œé™€èºä»ªåç½®
   51          // å‚æ•°è¯´æ˜     void
   52          // è¿”å›å‚æ•°     void
   53          // ä½¿ç”¨ç¤ºä¾‹     quaternion_init();
   54          //-------------------------------------------------------------------------------------------------------
C251 COMPILER V5.60.0,  IMU                                                                15/06/25  00:02:59  PAGE 2   

             -------------
   55          void quaternion_init(void) 
   56          {
   57   1          /* åˆå§‹åŒ–ä¸ºå•ä½å››å…ƒæ•° */
   58   1          q.w = 1.0f;
   59   1          q.x = 0.0f;
   60   1          q.y = 0.0f;
   61   1          q.z = 0.0f;
   62   1          
   63   1          /* åˆå§‹åŒ–é™€èºä»ªåç½® */
   64   1          imu_data.gyro_x = 0.0f;
   65   1          imu_data.gyro_y = 0.0f;
   66   1          imu_data.gyro_z = 0.0f;
   67   1      }
   68          
   69          //-------------------------------------------------------------------------------------------------------
             -------------
   70          // å‡½æ•°ç®€ä»‹     è§’é€Ÿåº¦æ•°æ®ä½é€šæ»¤æ³¢å‡½æ•°ï¼Œç”¨äºæ»¤é™¤å°å¹…åº¦å™ªå£°
   71          // å‚æ•°è¯´æ˜     cy: è¾“å…¥çš„è§’é€Ÿåº¦å€¼
   72          // è¿”å›å‚æ•°     float: æ»¤æ³¢åçš„è§’é€Ÿåº¦å€¼
   73          // ä½¿ç”¨ç¤ºä¾‹     filtered_gyro = IMU_lvbo(raw_gyro);
   74          //-------------------------------------------------------------------------------------------------------
             -------------
   75          float IMU_lvbo(float cy)
   76          {
   77   1          if (cy < 0.15f && cy > -0.15f)
   78   1          {
   79   2              cy = 0.0f;
   80   2          }
   81   1          return cy;
   82   1      }
   83          
   84          //-------------------------------------------------------------------------------------------------------
             -------------
   85          // å‡½æ•°ç®€ä»‹     é™€èºä»ªæ ¡å‡†å‡½æ•°ï¼Œç”¨äºè®¡ç®—é™€èºä»ªçš„é›¶åå€¼
   86          // å‚æ•°è¯´æ˜     samples: é‡‡æ ·ç‚¹æ•°
   87          // è¿”å›å‚æ•°     void
   88          // ä½¿ç”¨ç¤ºä¾‹     gyro_calibrate(200);
   89          //-------------------------------------------------------------------------------------------------------
             -------------
   90          void gyro_calibrate(uint16 samples) 
   91          {
   92   1          uint16 i;
   93   1          
   94   1          /* æ¸…é™¤æ ¡å‡†å‰çš„æ•°æ® */
   95   1          imu_data.gyro_x = 0.0f;
   96   1          imu_data.gyro_y = 0.0f;
   97   1          imu_data.gyro_z = 0.0f;
   98   1          
   99   1          /* æ¸…é™¤å±å¹•ï¼Œæç¤ºæ ¡å‡†å¼€å§‹ */
  100   1          ips200_clear(RGB565_WHITE);
  101   1          ips200_show_string(0, 0, "imu gyro calibrate...");
  102   1          ips200_show_string(0, 20, "please keep still");
  103   1          
  104   1          /* æ”¶é›†å¤šä¸ªæ ·æœ¬æ±‚å¹³å‡å€¼ */
  105   1          for(i = 0; i < samples; i++) 
  106   1          {
  107   2              imu660ra_get_gyro();
  108   2              
  109   2              imu_data.gyro_x += (float)imu660ra_gyro_x;
  110   2              imu_data.gyro_y += (float)imu660ra_gyro_y;
  111   2              imu_data.gyro_z += (float)imu660ra_gyro_z;
  112   2              
  113   2              /* æ›´æ–°è¿›åº¦ */
  114   2              if(i % 10 == 0) 
  115   2              {
C251 COMPILER V5.60.0,  IMU                                                                15/06/25  00:02:59  PAGE 3   

  116   3                  sprintf(txt, "progress: %d%%", (int)(i * 100 / samples));
  117   3                  ips200_show_string(0, 40, txt);
  118   3              }
  119   2              
  120   2              system_delay_ms(5);
  121   2          }
  122   1          
  123   1          /* è®¡ç®—åç½® */
  124   1          imu_data.gyro_x = imu_data.gyro_x / (float)samples;
  125   1          imu_data.gyro_y = imu_data.gyro_y / (float)samples;
  126   1          imu_data.gyro_z = imu_data.gyro_z / (float)samples;
  127   1          
  128   1          /* æ˜¾ç¤ºæ ¡å‡†ç»“æœ */
  129   1          sprintf(txt, "bias_x: %.2f", imu_data.gyro_x);
  130   1          ips200_show_string(0, 60, txt);
  131   1          sprintf(txt, "bias_y: %.2f", imu_data.gyro_y);
  132   1          ips200_show_string(0, 80, txt);
  133   1          sprintf(txt, "bias_z: %.2f", imu_data.gyro_z);
  134   1          ips200_show_string(0, 100, txt);
  135   1          
  136   1          ips200_show_string(0, 120, "calibrate done!");
  137   1          system_delay_ms(500);
  138   1      }
  139          
  140          //-------------------------------------------------------------------------------------------------------
             -------------
  141          // å‡½æ•°ç®€ä»‹     å››å…ƒæ•°å½’ä¸€åŒ–å‡½æ•°ï¼Œç”¨äºä¿æŒå››å…ƒæ•°çš„å•ä½é•¿åº¦
  142          // å‚æ•°è¯´æ˜     q: æŒ‡å‘å¾…å½’ä¸€åŒ–çš„å››å…ƒæ•°çš„æŒ‡é’ˆ
  143          // è¿”å›å‚æ•°     void
  144          // ä½¿ç”¨ç¤ºä¾‹     quat_normalize(&q);
  145          //-------------------------------------------------------------------------------------------------------
             -------------
  146          void quat_normalize(Quaternion* q)
  147          {
  148   1          float norm = sqrt(q->w*q->w + q->x*q->x + q->y*q->y + q->z*q->z);
  149   1          
  150   1          /* é˜²æ­¢é™¤ä»¥é›¶ */
  151   1          if(norm < 0.0001f)
  152   1          {
  153   2              q->w = 1.0f;
  154   2              q->x = 0.0f;
  155   2              q->y = 0.0f;
  156   2              q->z = 0.0f;
  157   2              return;
  158   2          }
  159   1          
  160   1          q->w = q->w / norm;
  161   1          q->x = q->x / norm;
  162   1          q->y = q->y / norm;
  163   1          q->z = q->z / norm;
  164   1      }
  165          
  166          //-------------------------------------------------------------------------------------------------------
             -------------
  167          // å‡½æ•°ç®€ä»‹     å››å…ƒæ•°æ›´æ–°å‡½æ•°ï¼Œç”¨äºæ ¹æ®é™€èºä»ªæ•°æ®æ›´æ–°å››å…ƒæ•°
  168          // å‚æ•°è¯´æ˜     void
  169          // è¿”å›å‚æ•°     void
  170          // ä½¿ç”¨ç¤ºä¾‹     quaternion_update();
  171          //-------------------------------------------------------------------------------------------------------
             -------------
  172          void quaternion_update(void) 
  173          {
  174   1          float gx, gy, gz;
  175   1          float qDot1, qDot2, qDot3, qDot4;
  176   1          
  177   1          /* è¯»å–IMUä¼ æ„Ÿå™¨æ•°æ® */
C251 COMPILER V5.60.0,  IMU                                                                15/06/25  00:02:59  PAGE 4   

  178   1          imu660ra_get_gyro();
  179   1          
  180   1          /* å¤„ç†é™€èºä»ªæ•°æ®ï¼Œå‡å»åç½®å¹¶è½¬æ¢ä¸ºå¼§åº¦/ç§’ */
  181   1          gx = imu660ra_gyro_transition((float)imu660ra_gyro_x - imu_data.gyro_x);
  182   1          gy = imu660ra_gyro_transition((float)imu660ra_gyro_y - imu_data.gyro_y);
  183   1          gz = imu660ra_gyro_transition((float)imu660ra_gyro_z - imu_data.gyro_z);
  184   1          
  185   1          /* åº”ç”¨ä½é€šæ»¤æ³¢ */
  186   1          gx = IMU_lvbo(gx);
  187   1          gy = IMU_lvbo(gy);
  188   1          gz = IMU_lvbo(gz);
  189   1          
  190   1          /* åŸºäºå››å…ƒæ•°å¾®åˆ†æ–¹ç¨‹è¿›è¡Œç§¯åˆ†æ›´æ–° */
  191   1          /* q_dot = 0.5 * q âŠ— Ï‰ï¼Œå…¶ä¸­Ï‰ä¸ºè§’é€Ÿåº¦å››å…ƒæ•°[0,gx,gy,gz] */
  192   1          qDot1 = 0.5f * (-q.x * gx - q.y * gy - q.z * gz);
  193   1          qDot2 = 0.5f * (q.w * gx + q.y * gz - q.z * gy);
  194   1          qDot3 = 0.5f * (q.w * gy - q.x * gz + q.z * gx);
  195   1          qDot4 = 0.5f * (q.w * gz + q.x * gy - q.y * gx);
  196   1          
  197   1          /* ä½¿ç”¨æ¬§æ‹‰ç§¯åˆ†æ³•æ›´æ–°å››å…ƒæ•° */
  198   1          q.w = q.w + qDot1 * SAMPLE_FREQ/4.8;
  199   1          q.x = q.x + qDot2 * SAMPLE_FREQ/4.8;
  200   1          q.y = q.y + qDot3 * SAMPLE_FREQ/4.8;
  201   1          q.z = q.z + qDot4 * SAMPLE_FREQ/4.8;
  202   1          
  203   1          /* å››å…ƒæ•°å½’ä¸€åŒ– */
  204   1          quat_normalize(&q);
  205   1          
  206   1          /* è®¡ç®—æ¬§æ‹‰è§’ */
  207   1          euler = quaternion_to_euler(q);
  208   1      }
  209          //-------------------------------------------------------------------------------------------------------
             -------------
  210          // å‡½æ•°ç®€ä»‹     å››å…ƒæ•°è½¬æ¬§æ‹‰è§’å‡½æ•°ï¼Œä»…è®¡ç®—åèˆªè§’
  211          // å‚æ•°è¯´æ˜     q: è¾“å…¥çš„å››å…ƒæ•°
  212          // è¿”å›å‚æ•°     EulerAngle: è®¡ç®—å¾—åˆ°çš„æ¬§æ‹‰è§’ï¼ˆä»…åèˆªè§’æœ‰æ•ˆï¼‰
  213          // ä½¿ç”¨ç¤ºä¾‹     EulerAngle angles = quaternion_to_euler(current_q);
  214          //-------------------------------------------------------------------------------------------------------
             -------------
  215          EulerAngle quaternion_to_euler(Quaternion q) 
  216          {
  217   1          float siny_cosp, cosy_cosp;
  218   1          
  219   1          /* åˆå§‹åŒ–å…¶ä»–è§’åº¦ä¸º0 */
  220   1          euler.roll = 0.0f;
  221   1          euler.pitch = 0.0f;
  222   1          
  223   1          /* è®¡ç®—åèˆªè§’ (Yaw) */
  224   1          siny_cosp = 2.0f * (q.w * q.z + q.x * q.y);
  225   1          cosy_cosp = 1.0f - 2.0f * (q.y * q.y + q.z * q.z);
  226   1          euler.yaw = atan2(siny_cosp, cosy_cosp);
  227   1          
  228   1          /* è½¬æ¢ä¸ºè§’åº¦ */
  229   1          euler.yaw = euler.yaw * 180.0f / PI;
  230   1          
  231   1          return euler;
  232   1      }
  233          
  234          //-------------------------------------------------------------------------------------------------------
             -------------
  235          // å‡½æ•°ç®€ä»‹     å››å…ƒæ•°æ˜¾ç¤ºå‡½æ•°ï¼Œç”¨äºåœ¨IPSå±å¹•ä¸Šæ˜¾ç¤ºå››å…ƒæ•°å’Œæ¬§æ‹‰è§’
  236          // å‚æ•°è¯´æ˜     void
  237          // è¿”å›å‚æ•°     void
  238          // ä½¿ç”¨ç¤ºä¾‹     quaternion_display();
  239          //-------------------------------------------------------------------------------------------------------
             -------------
C251 COMPILER V5.60.0,  IMU                                                                15/06/25  00:02:59  PAGE 5   

  240          void quaternion_display(void) 
  241          {
  242   1          /* æ˜¾ç¤ºå››å…ƒæ•° */
  243   1          sprintf(txt, "Q.w: %.4f", q.w);
  244   1          ips200_show_string(0, 0, txt);
  245   1          sprintf(txt, "Q.x: %.4f", q.x);
  246   1          ips200_show_string(0, 16, txt);
  247   1          sprintf(txt, "Q.y: %.4f", q.y);
  248   1          ips200_show_string(0, 32, txt);
  249   1          sprintf(txt, "Q.z: %.4f", q.z);
  250   1          ips200_show_string(0, 48, txt);
  251   1          
  252   1          /* æ˜¾ç¤ºæ¬§æ‹‰è§’ */
  253   1          sprintf(txt, "Yaw  : %.2f", euler.yaw);
  254   1          ips200_show_string(0, 112, txt);
  255   1      }
  256          
  257          //-------------------------------------------------------------------------------------------------------
             -------------
  258          // å‡½æ•°ç®€ä»‹     IMUä¸­æ–­æœåŠ¡å‡½æ•°ï¼Œç”¨äºå¤„ç†IMUæ•°æ®æ›´æ–°
  259          // å‚æ•°è¯´æ˜     void
  260          // è¿”å›å‚æ•°     void
  261          // ä½¿ç”¨ç¤ºä¾‹     ç”±å®šæ—¶å™¨ä¸­æ–­è‡ªåŠ¨è°ƒç”¨
  262          //-------------------------------------------------------------------------------------------------------
             -------------
  263          void imu_isr(void)
  264          {
  265   1          /* æ›´æ–°å››å…ƒæ•° */
  266   1          quaternion_update();
  267   1      }
  268          //-------------------------------------------------------------------------------------------------------
             -------------
  269          // å‡½æ•°ç®€ä»‹     ç®€æ˜“æƒ¯æ€§å¯¼èˆªå­˜å…¥
  270          // å‚æ•°è¯´æ˜     void
  271          // è¿”å›å‚æ•°     void
  272          // ä½¿ç”¨ç¤ºä¾‹     encoder_ins_infile();
  273          //-------------------------------------------------------------------------------------------------------
             -------------
  274          void encoder_ins_infile(void) 
  275          {
  276   1          static uint8 encoder_ins_last_memory_flag=0;
  277   1          encoder_integral_flag=1;
  278   1          if(!encoder_ins_memory_flag){encoder_ins_last_memory_flag=0;return;}//å­˜å‚¨å¼€å¯æ ‡å¿—
  279   1          if(!encoder_ins_last_memory_flag){encoder_ins_num=0;encoder_ins_last_memory_flag=1;}//ä¸Šä¸€æ¬¡æ¯”å¯¹
             -åˆ¤æ–­æ˜¯å¦ç¬¬ä¸€æ¬¡è¿›å…¥å­˜å‚¨å¹¶å½’ä½
  280   1          if(encoder_ins_num==0){encoder_file[encoder_ins_num]=euler.yaw;encoder_ins_num++;}//ç¬¬ä¸€æ¬¡å­˜å‚¨ç›
             -´æ¥è®°å½•å½“å‰è§’åº¦
  281   1          if(encoder_ins_num==1000)return;
  282   1          if(encoder_integral_1+encoder_integral_2<speed_threshold)return;//è„‰å†²è®¡æ•°
  283   1          encoder_integral_1=0;
  284   1          encoder_integral_2=0;
  285   1          // encoder_del=encoder_data_dir_1-encoder_data_dir_2;
  286   1          encoder_file[encoder_ins_num]=euler.yaw;
  287   1          encoder_ins_num++;
  288   1      }
  289          //-------------------------------------------------------------------------------------------------------
             -------------
  290          // å‡½æ•°ç®€ä»‹     ç®€æ˜“æƒ¯æ€§å¯¼èˆªå®ç°
  291          // å‚æ•°è¯´æ˜     void
  292          // è¿”å›å‚æ•°     void
  293          // ä½¿ç”¨ç¤ºä¾‹     encoder_ins();
  294          //-------------------------------------------------------------------------------------------------------
             -------------
  295          void encoder_ins(void)
  296          {
  297   1          static uint8 frist_in_flag;//ç¬¬ä¸€æ¬¡è¿›å…¥æ ‡å¿—ä½
C251 COMPILER V5.60.0,  IMU                                                                15/06/25  00:02:59  PAGE 6   

  298   1          static uint16 encoder_ins_num_record;
  299   1          if(!ins_go_flag){frist_in_flag=0;return;}
  300   1          if(!frist_in_flag){encoder_ins_num_record=encoder_ins_num;encoder_ins_num=0;frist_in_flag=1;}//è®°å½•
             -æƒ¯æ€§å­˜å‚¨çš„æ€»æ•°ï¼Œå¹¶å½’ä½è®¡æ•°
  301   1          target_speed=ins_speed;//æ€»æ§é€Ÿåº¦
  302   1          target_angle=encoder_file[encoder_ins_num];//æ€»æ§è§’åº¦
  303   1          if(encoder_integral_1+encoder_integral_2>=speed_threshold){//è®¡æ•°æ›´æ–°
  304   2              encoder_integral_1=0;
  305   2              encoder_integral_2=0;
  306   2              encoder_ins_num++;
  307   2          }
  308   1          if(encoder_ins_num>=encoder_ins_num_record){ins_go_flag=0;target_speed=0;return;}//åœè½¦
  309   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      3387     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =      4120     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       296     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
