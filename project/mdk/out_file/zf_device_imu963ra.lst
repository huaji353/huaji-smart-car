C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 07/05/25  16:28:03  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_device_imu963ra
OBJECT MODULE PLACED IN .\out_file\zf_device_imu963ra.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE ..\..\libraries\zf_device\zf_device_imu963ra.c LARGE NOALIAS WARNINGLE
                    -VEL(3) OPTIMIZE(0,SIZE) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;
                    -..\..\libraries\zf_driver;..\user;..\code) DEBUG PRINT(.\out_file\zf_device_imu963ra.lst) TABS(2) OBJECT(.\out_file\zf_d
                    -evice_imu963ra.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * AI8051U Opensourec Library å³ï¼ˆAI8051U å¼€æºåº“ï¼‰æ˜¯ä¸€ä¸ªåŸºäºå®˜æ–¹ SDK æ¥å£çš„ç¬¬ä¸‰æ–¹å¼€æº
             -åº“
    3          * Copyright (c) 2022 SEEKFREE é€é£ç§‘æŠ€
    4          *
    5          * æœ¬æ–‡ä»¶æ˜¯STC å¼€æºåº“çš„ä¸€éƒ¨åˆ†
    6          *
    7          * AI8051U å¼€æºåº“ æ˜¯å…è´¹è½¯ä»¶
    8          * æ‚¨å¯ä»¥æ ¹æ®è‡ªç”±è½¯ä»¶åŸºé‡‘ä¼šå‘å¸ƒçš„ GPLï¼ˆGNU General Public Licenseï¼Œå³ GNUé€šç”¨å…¬å…±è®¸
             -å¯è¯ï¼‰çš„æ¡æ¬¾
    9          * å³ GPL çš„ç¬¬3ç‰ˆï¼ˆå³ GPL3.0ï¼‰æˆ–ï¼ˆæ‚¨é€‰æ‹©çš„ï¼‰ä»»ä½•åæ¥çš„ç‰ˆæœ¬ï¼Œé‡æ–°å‘å¸ƒå’Œ/æˆ–ä¿®æ”
             -¹å®ƒ
   10          *
   11          * æœ¬å¼€æºåº“çš„å‘å¸ƒæ˜¯å¸Œæœ›å®ƒèƒ½å‘æŒ¥ä½œç”¨ï¼Œä½†å¹¶æœªå¯¹å…¶ä½œä»»ä½•çš„ä¿è¯
   12          * ç”šè‡³æ²¡æœ‰éšå«çš„é€‚é”€æ€§æˆ–é€‚åˆç‰¹å®šç”¨é€”çš„ä¿è¯
   13          * æ›´å¤šç»†èŠ‚è¯·å‚è§ GPL
   14          *
   15          * æ‚¨åº”è¯¥åœ¨æ”¶åˆ°æœ¬å¼€æºåº“çš„åŒæ—¶æ”¶åˆ°ä¸€ä»½ GPL çš„å‰¯æœ¬
   16          * å¦‚æœæ²¡æœ‰ï¼Œè¯·å‚é˜…<https://www.gnu.org/licenses/>
   17          *
   18          * é¢å¤–æ³¨æ˜ï¼š
   19          * æœ¬å¼€æºåº“ä½¿ç”¨ GPL3.0 å¼€æºè®¸å¯è¯åè®® ä»¥ä¸Šè®¸å¯ç”³æ˜ä¸ºè¯‘æ–‡ç‰ˆæœ¬
   20          * è®¸å¯ç”³æ˜è‹±æ–‡ç‰ˆåœ¨ libraries/doc æ–‡ä»¶å¤¹ä¸‹çš„ GPL3_permission_statement.txt æ–‡ä»¶ä¸­
   21          * è®¸å¯è¯å‰¯æœ¬åœ¨ libraries æ–‡ä»¶å¤¹ä¸‹ å³è¯¥æ–‡ä»¶å¤¹ä¸‹çš„ LICENSE æ–‡ä»¶
   22          * æ¬¢è¿å„ä½ä½¿ç”¨å¹¶ä¼ æ’­æœ¬ç¨‹åº ä½†ä¿®æ”¹å†…å®¹æ—¶å¿…é¡»ä¿ç•™é€é£ç§‘æŠ€çš„ç‰ˆæƒå£°æ˜ï¼ˆå³æœ¬
             -å£°æ˜ï¼‰
   23          *
   24          * æ–‡ä»¶åç§°          
   25          * å…¬å¸åç§°          æˆéƒ½é€é£ç§‘æŠ€æœ‰é™å…¬å¸
   26          * ç‰ˆæœ¬ä¿¡æ¯          æŸ¥çœ‹ libraries/doc æ–‡ä»¶å¤¹å†… version æ–‡ä»¶ ç‰ˆæœ¬è¯´æ˜
   27          * å¼€å‘ç¯å¢ƒ          MDK FOR C251
   28          * é€‚ç”¨å¹³å°          AI8051U
   29          * åº—é“ºé“¾æ¥          https://seekfree.taobao.com/
   30          *
   31          * ä¿®æ”¹è®°å½•
   32          * æ—¥æœŸ              ä½œè€…           å¤‡æ³¨
   33          * 2024-08-01        å¤§W            first version
   34          *********************************************************************************************************
             -***********/
   35          /********************************************************************************************************
             -*************
   36          * æ¥çº¿å®šä¹‰ï¼š
   37          *                   ------------------------------------
   38          *                   æ¨¡å—ç®¡è„š            å•ç‰‡æœºç®¡è„š
   39          *                   // ç¡¬ä»¶ SPI å¼•è„š
   40          *                   SCL/SPC             æŸ¥çœ‹ zf_device_imu963ra.h ä¸­ IMU963RA_SPC_PIN å®å®šä¹‰
   41          *                   SDA/DSI             æŸ¥çœ‹ zf_device_imu963ra.h ä¸­ IMU963RA_SDI_PIN å®å®šä¹‰
   42          *                   SA0/SDO             æŸ¥çœ‹ zf_device_imu963ra.h ä¸­ IMU963RA_SDO_PIN å®å®šä¹‰
   43          *                   CS                  æŸ¥çœ‹ zf_device_imu963ra.h ä¸­ IMU963RA_CS_PIN  å®å®šä¹‰
   44          *                   VCC                 3.3Vç”µæº
   45          *                   GND                 ç”µæºåœ°
   46          *                   å…¶ä½™å¼•è„šæ‚¬ç©º
   47          *
   48          *                   // è½¯ä»¶ IIC å¼•è„š
   49          *                   SCL/SPC             æŸ¥çœ‹ zf_device_imu963ra.h ä¸­ IMU963RA_SCL_PIN å®å®šä¹‰
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 07/05/25  16:28:03  PAGE 2   

   50          *                   SDA/DSI             æŸ¥çœ‹ zf_device_imu963ra.h ä¸­ IMU963RA_SDA_PIN å®å®šä¹‰
   51          *                   VCC                 3.3Vç”µæº
   52          *                   GND                 ç”µæºåœ°
   53          *                   å…¶ä½™å¼•è„šæ‚¬ç©º
   54          *                   ------------------------------------
   55          *********************************************************************************************************
             -***********/
   56          
   57          #include "zf_common_clock.h"
   58          #include "zf_common_debug.h"
   59          #include "zf_driver_delay.h"
   60          #include "zf_driver_spi.h"
   61          #include "zf_driver_soft_iic.h"
   62          
   63          #include "zf_device_imu963ra.h"
   64          
   65          #pragma warning disable = 183
   66          #pragma warning disable = 177
   67          
   68          int16 imu963ra_gyro_x = 0, imu963ra_gyro_y = 0, imu963ra_gyro_z = 0;
   69          int16 imu963ra_acc_x = 0,  imu963ra_acc_y = 0,  imu963ra_acc_z = 0;
   70          int16 imu963ra_mag_x = 0,  imu963ra_mag_y = 0,  imu963ra_mag_z = 0;
   71          float imu963ra_transition_factor[3] = {4098, 14.3, 3000};
   72          
   73          #if IMU963RA_USE_SOFT_IIC
               static soft_iic_info_struct imu963ra_iic_struct;
               
               //-------------------------------------------------------------------------------------------------------
             -------------
               // å‡½æ•°ç®€ä»‹     IMU963RA å†™å¯„å­˜å™¨
               // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
               // å‚æ•°è¯´æ˜     dat            æ•°æ®
               // è¿”å›å‚æ•°     void
               // ä½¿ç”¨ç¤ºä¾‹     imu963ra_write_acc_gyro_register(IMU963RA_SLV0_CONFIG, 0x00);
               // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
               //-------------------------------------------------------------------------------------------------------
             -------------
               #define imu963ra_write_acc_gyro_register(reg,dat)       (soft_iic_write_8bit_register(&imu963ra_iic_struc
             -t,reg,dat))
               
               //-------------------------------------------------------------------------------------------------------
             -------------
               // å‡½æ•°ç®€ä»‹     IMU963RA è¯»å¯„å­˜å™¨
               // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
               // è¿”å›å‚æ•°     uint8           æ•°æ®
               // ä½¿ç”¨ç¤ºä¾‹     imu963ra_read_acc_gyro_register(IMU963RA_STATUS_MASTER);
               // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
               //-------------------------------------------------------------------------------------------------------
             -------------
               #define imu963ra_read_acc_gyro_register(reg)             (soft_iic_sccb_read_register(&imu963ra_iic_struc
             -t,reg))
               
               //-------------------------------------------------------------------------------------------------------
             -------------
               // å‡½æ•°ç®€ä»‹     IMU963RA è¯»æ•°æ® å†…éƒ¨è°ƒç”¨
               // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
               // å‚æ•°è¯´æ˜     dat            æ•°æ®ç¼“å†²åŒº
               // å‚æ•°è¯´æ˜     len             æ•°æ®é•¿åº¦
               // è¿”å›å‚æ•°     void
               // ä½¿ç”¨ç¤ºä¾‹     imu963ra_read_acc_gyro_registers(IMU963RA_OUTX_L_A, dat, 6);
               // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
               //-------------------------------------------------------------------------------------------------------
             -------------
               #define imu963ra_read_acc_gyro_registers(reg,dat,len)   (soft_iic_read_8bit_registers(&imu963ra_iic_struc
             -t,reg,dat,len))
               #else
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 07/05/25  16:28:03  PAGE 3   

  106          //-------------------------------------------------------------------------------------------------------
             -------------
  107          // å‡½æ•°ç®€ä»‹     IMU963RA å†™å¯„å­˜å™¨
  108          // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
  109          // å‚æ•°è¯´æ˜     dat            æ•°æ®
  110          // è¿”å›å‚æ•°     void
  111          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_write_acc_gyro_register(IMU963RA_SLV0_CONFIG, 0x00);
  112          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  113          //-------------------------------------------------------------------------------------------------------
             -------------
  114          static void imu963ra_write_acc_gyro_register(uint8 reg, uint8 dat)
  115          {
  116   1          IMU963RA_CS(0);
  117   1          spi_write_8bit_register(IMU963RA_SPI, reg | IMU963RA_SPI_W, dat);
  118   1          
  119   1          IMU963RA_CS(1);
  120   1      }
  121          
  122          //-------------------------------------------------------------------------------------------------------
             -------------
  123          // å‡½æ•°ç®€ä»‹     IMU963RA è¯»å¯„å­˜å™¨
  124          // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
  125          // è¿”å›å‚æ•°     uint8           æ•°æ®
  126          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_read_acc_gyro_register(IMU963RA_STATUS_MASTER);
  127          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  128          //-------------------------------------------------------------------------------------------------------
             -------------
  129          static uint8 imu963ra_read_acc_gyro_register(uint8 reg)
  130          {
  131   1          uint8 dat = 0;
  132   1          IMU963RA_CS(0);
  133   1          dat = spi_read_8bit_register(IMU963RA_SPI, reg | IMU963RA_SPI_R);
  134   1          IMU963RA_CS(1);
  135   1          return dat;
  136   1      }
  137          
  138          //-------------------------------------------------------------------------------------------------------
             -------------
  139          // å‡½æ•°ç®€ä»‹     IMU963RA è¯»æ•°æ® å†…éƒ¨è°ƒç”¨
  140          // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
  141          // å‚æ•°è¯´æ˜     dat            æ•°æ®ç¼“å†²åŒº
  142          // å‚æ•°è¯´æ˜     len             æ•°æ®é•¿åº¦
  143          // è¿”å›å‚æ•°     void
  144          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_read_acc_gyro_registers(IMU963RA_OUTX_L_A, dat, 6);
  145          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  146          //-------------------------------------------------------------------------------------------------------
             -------------
  147          static void imu963ra_read_acc_gyro_registers(uint8 reg, uint8 *dat, uint32 len)
  148          {
  149   1          IMU963RA_CS(0);
  150   1          spi_read_8bit_registers(IMU963RA_SPI, reg | IMU963RA_SPI_R, dat, len);
  151   1          
  152   1          IMU963RA_CS(1);
  153   1      }
  154          #endif
  155          
  156          //-------------------------------------------------------------------------------------------------------
             -------------
  157          // å‡½æ•°ç®€ä»‹     IMU963RA ä½œä¸º IIC ä¸»æœºå‘ç£åŠ›è®¡å†™æ•°æ®
  158          // å‚æ•°è¯´æ˜     addr            ç›®æ ‡åœ°å€
  159          // å‚æ•°è¯´æ˜     reg             ç›®æ ‡å¯„å­˜å™¨
  160          // å‚æ•°è¯´æ˜     dat            æ•°æ®
  161          // è¿”å›å‚æ•°     uint8           1-å¤±è´¥ 0-æˆåŠŸ
  162          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_write_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_CONTROL2, 0x80);
  163          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  164          //-------------------------------------------------------------------------------------------------------
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 07/05/25  16:28:03  PAGE 4   

             -------------
  165          static uint8 imu963ra_write_mag_register (uint8 addr, uint8 reg, uint8 dat)
  166          {
  167   1          uint8 return_state = 0;
  168   1          uint16 timeout_count = 0;
  169   1          
  170   1          addr = addr << 1;
  171   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_CONFIG, 0x00);               // ä»æœº0é…ç½®æ¸…é™¤
  172   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_ADD, addr | 0);              // è®¾ç½®åœ°ç£è®¡åœ°å€ï
             -¼ˆæ³¨æ„è¿™é‡Œéœ€è¦è®¾ç½®8ä½çš„I2Cåœ°å€ï¼‰ 0x2C
  173   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_SUBADD, reg);                // éœ€è¦å†™å…¥çš„å¯„å­˜å
             -™¨åœ°å€
  174   1          imu963ra_write_acc_gyro_register(IMU963RA_DATAWRITE_SLV0, dat);            // éœ€è¦å†™å…¥çš„æ•°æ®
  175   1          imu963ra_write_acc_gyro_register(IMU963RA_MASTER_CONFIG, 0x4C);             // ä»…åœ¨ç¬¬ä¸€ä¸ªå‘¨æœŸå
             -¯ç”¨é€šè®¯ å¼€å¯ä¸Šæ‹‰ I2Cä¸»æœºä½¿èƒ½
  176   1          
  177   1          // ç­‰å¾…é€šè®¯æˆåŠŸ
  178   1          while(0 == (0x80 & imu963ra_read_acc_gyro_register(IMU963RA_STATUS_MASTER)))
  179   1          {
  180   2              if(IMU963RA_TIMEOUT_COUNT < timeout_count ++)
  181   2              {
  182   3                  return_state = 1;
  183   3                  break;
  184   3              }
  185   2              
  186   2              system_delay_ms(2);
  187   2          }
  188   1          
  189   1          return return_state;
  190   1      }
  191          
  192          //-------------------------------------------------------------------------------------------------------
             -------------
  193          // å‡½æ•°ç®€ä»‹     IMU963RA ä½œä¸º IIC ä¸»æœºå‘ç£åŠ›è®¡è¯»æ•°æ®
  194          // å‚æ•°è¯´æ˜     addr            ç›®æ ‡åœ°å€
  195          // å‚æ•°è¯´æ˜     reg             ç›®æ ‡å¯„å­˜å™¨
  196          // è¿”å›å‚æ•°     uint8           è¯»å–çš„æ•°æ®
  197          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_read_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_CHIP_ID);
  198          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  199          //-------------------------------------------------------------------------------------------------------
             -------------
  200          static uint8 imu963ra_read_mag_register (uint8 addr, uint8 reg)
  201          {
  202   1          uint16 timeout_count = 0;
  203   1          
  204   1          addr = addr << 1;
  205   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_ADD, addr | 1);              // è®¾ç½®åœ°ç£è®¡åœ°å€ï
             -¼ˆæ³¨æ„è¿™é‡Œéœ€è¦è®¾ç½®8ä½çš„I2Cåœ°å€ï¼‰ 0x2C
  206   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_SUBADD, reg);                // éœ€è¦è¯»å–çš„å¯„å­˜å
             -™¨åœ°å€
  207   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_CONFIG, 0x01);
  208   1          imu963ra_write_acc_gyro_register(IMU963RA_MASTER_CONFIG, 0x4C);             // ä»…åœ¨ç¬¬ä¸€ä¸ªå‘¨æœŸå
             -¯ç”¨é€šè®¯ å¼€å¯ä¸Šæ‹‰ I2Cä¸»æœºä½¿èƒ½
  209   1          
  210   1          // ç­‰å¾…é€šè®¯æˆåŠŸ
  211   1          while(0 == (0x01 & imu963ra_read_acc_gyro_register(IMU963RA_STATUS_MASTER)))
  212   1          {
  213   2              if(IMU963RA_TIMEOUT_COUNT < timeout_count ++)
  214   2              {
  215   3                  break;
  216   3              }
  217   2              
  218   2              system_delay_ms(2);
  219   2          }
  220   1          
  221   1          return (imu963ra_read_acc_gyro_register(IMU963RA_SENSOR_HUB_1));            // è¿”å›è¯»å–åˆ°çš„æ•°æ
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 07/05/25  16:28:03  PAGE 5   

             -®
  222   1      }
  223          
  224          //-------------------------------------------------------------------------------------------------------
             -------------
  225          // å‡½æ•°ç®€ä»‹     IMU963RA ä½œä¸º IIC ä¸»æœºå‘ç£åŠ›è®¡è‡ªåŠ¨å†™æ•°æ®
  226          // å‚æ•°è¯´æ˜     addr            ç›®æ ‡åœ°å€
  227          // å‚æ•°è¯´æ˜     reg             ç›®æ ‡å¯„å­˜å™¨
  228          // è¿”å›å‚æ•°     void
  229          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_connect_mag(IMU963RA_MAG_ADDR, IMU963RA_MAG_OUTX_L);
  230          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  231          //-------------------------------------------------------------------------------------------------------
             -------------
  232          static void imu963ra_connect_mag (uint8 addr, uint8 reg)
  233          {
  234   1          addr = addr << 1;
  235   1          
  236   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_ADD, addr | 1);              // è®¾ç½®åœ°ç£è®¡åœ°å€ï
             -¼ˆæ³¨æ„è¿™é‡Œéœ€è¦è®¾ç½®8ä½çš„I2Cåœ°å€ï¼‰ 0x2C
  237   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_SUBADD, reg);                // éœ€è¦è¯»å–çš„å¯„å­˜å
             -™¨åœ°å€
  238   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_CONFIG, 0x06);
  239   1          imu963ra_write_acc_gyro_register(IMU963RA_MASTER_CONFIG, 0x6C);             // ä»…åœ¨ç¬¬ä¸€ä¸ªå‘¨æœŸå
             -¯ç”¨é€šè®¯ å¼€å¯ä¸Šæ‹‰ I2Cä¸»æœºä½¿èƒ½
  240   1      }
  241          
  242          
  243          //-------------------------------------------------------------------------------------------------------
             -------------
  244          // å‡½æ•°ç®€ä»‹     IMU963RA å…­è½´è‡ªæ£€ å†…éƒ¨è°ƒç”¨
  245          // å‚æ•°è¯´æ˜     void
  246          // è¿”å›å‚æ•°     uint8           1-è‡ªæ£€å¤±è´¥ 0-è‡ªæ£€æˆåŠŸ
  247          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_acc_gyro_self_check();
  248          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  249          //-------------------------------------------------------------------------------------------------------
             -------------
  250          static uint8 imu963ra_acc_gyro_self_check (void)
  251          {
  252   1          uint8 return_state = 0;
  253   1          uint8 dat = 0;
  254   1          uint16 timeout_count = 0;
  255   1          
  256   1          while(0x6B != dat)                                                          // åˆ¤æ–­ ID æ˜¯å¦æ­£ç¡®
  257   1          {
  258   2              if(IMU963RA_TIMEOUT_COUNT < timeout_count ++)
  259   2              {
  260   3                  return_state = 1;
  261   3                  break;
  262   3              }
  263   2              
  264   2              dat = imu963ra_read_acc_gyro_register(IMU963RA_WHO_AM_I);
  265   2              system_delay_ms(10);
  266   2          }
  267   1          
  268   1          return return_state;
  269   1      }
  270          
  271          //-------------------------------------------------------------------------------------------------------
             -------------
  272          // å‡½æ•°ç®€ä»‹     IMU963RA ç£åŠ›è®¡è‡ªæ£€ å†…éƒ¨è°ƒç”¨
  273          // å‚æ•°è¯´æ˜     void
  274          // è¿”å›å‚æ•°     uint8           1-è‡ªæ£€å¤±è´¥ 0-è‡ªæ£€æˆåŠŸ
  275          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_mag_self_check();
  276          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  277          //-------------------------------------------------------------------------------------------------------
             -------------
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 07/05/25  16:28:03  PAGE 6   

  278          static uint8 imu963ra_mag_self_check (void)
  279          {
  280   1          uint8 return_state = 0;
  281   1          uint8 dat = 0;
  282   1          uint16 timeout_count = 0;
  283   1          
  284   1          while(0xff != dat)                                                          // åˆ¤æ–­ ID æ˜¯å¦æ­£ç¡®
  285   1          {
  286   2              if(IMU963RA_TIMEOUT_COUNT < timeout_count ++)
  287   2              {
  288   3                  return_state = 1;
  289   3                  break;
  290   3              }
  291   2              
  292   2              dat = imu963ra_read_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_CHIP_ID);
  293   2              system_delay_ms(10);
  294   2          }
  295   1          
  296   1          return return_state;
  297   1      }
  298          
  299          //-------------------------------------------------------------------------------------------------------
             -------------
  300          // å‡½æ•°ç®€ä»‹     è·å– IMU963RA åŠ é€Ÿåº¦è®¡æ•°æ®
  301          // å‚æ•°è¯´æ˜     void
  302          // è¿”å›å‚æ•°     void
  303          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_get_acc();
  304          // å¤‡æ³¨ä¿¡æ¯     æ‰§è¡Œè¯¥å‡½æ•°åï¼Œç›´æ¥æŸ¥çœ‹å¯¹åº”çš„å˜é‡å³å¯
  305          //-------------------------------------------------------------------------------------------------------
             -------------
  306          void imu963ra_get_acc (void)
  307          {
  308   1          uint8 dat[6];
  309   1          
  310   1          imu963ra_read_acc_gyro_registers(IMU963RA_OUTX_L_A, dat, 6);
  311   1          imu963ra_acc_x = (int16)(((uint16)dat[1] << 8 | dat[0]));
  312   1          imu963ra_acc_y = (int16)(((uint16)dat[3] << 8 | dat[2]));
  313   1          imu963ra_acc_z = (int16)(((uint16)dat[5] << 8 | dat[4]));
  314   1      }
  315          
  316          
  317          //-------------------------------------------------------------------------------------------------------
             -------------
  318          // å‡½æ•°ç®€ä»‹     è·å–IMU963RAé™€èºä»ªæ•°æ®
  319          // å‚æ•°è¯´æ˜     void
  320          // è¿”å›å‚æ•°     void
  321          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_get_gyro();
  322          // å¤‡æ³¨ä¿¡æ¯     æ‰§è¡Œè¯¥å‡½æ•°åï¼Œç›´æ¥æŸ¥çœ‹å¯¹åº”çš„å˜é‡å³å¯
  323          //-------------------------------------------------------------------------------------------------------
             -------------
  324          void imu963ra_get_gyro (void)
  325          {
  326   1          uint8 dat[6];
  327   1          
  328   1          imu963ra_read_acc_gyro_registers(IMU963RA_OUTX_L_G, dat, 6);
  329   1          imu963ra_gyro_x = (int16)(((uint16)dat[1] << 8 | dat[0]));
  330   1          imu963ra_gyro_y = (int16)(((uint16)dat[3] << 8 | dat[2]));
  331   1          imu963ra_gyro_z = (int16)(((uint16)dat[5] << 8 | dat[4]));
  332   1      }
  333          
  334          
  335          //-------------------------------------------------------------------------------------------------------
             -------------
  336          // å‡½æ•°ç®€ä»‹     è·å– IMU963RA ç£åŠ›è®¡æ•°æ®
  337          // å‚æ•°è¯´æ˜     void
  338          // è¿”å›å‚æ•°     void
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 07/05/25  16:28:03  PAGE 7   

  339          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_get_mag();
  340          // å¤‡æ³¨ä¿¡æ¯     æ‰§è¡Œè¯¥å‡½æ•°åï¼Œç›´æ¥æŸ¥çœ‹å¯¹åº”çš„å˜é‡å³å¯
  341          //-------------------------------------------------------------------------------------------------------
             -------------
  342          void imu963ra_get_mag (void)
  343          {
  344   1          uint8 temp_status;
  345   1          uint8 dat[6];
  346   1          
  347   1          imu963ra_write_acc_gyro_register(IMU963RA_FUNC_CFG_ACCESS, 0x40);
  348   1          temp_status = imu963ra_read_acc_gyro_register(IMU963RA_STATUS_MASTER);
  349   1          
  350   1          if(0x01 & temp_status)
  351   1          {
  352   2              imu963ra_read_acc_gyro_registers(IMU963RA_SENSOR_HUB_1, dat, 6);
  353   2              imu963ra_mag_x = (int16)(((uint16)dat[1] << 8 | dat[0]));
  354   2              imu963ra_mag_y = (int16)(((uint16)dat[3] << 8 | dat[2]));
  355   2              imu963ra_mag_z = (int16)(((uint16)dat[5] << 8 | dat[4]));
  356   2          }
  357   1          
  358   1          imu963ra_write_acc_gyro_register(IMU963RA_FUNC_CFG_ACCESS, 0x00);
  359   1      }
  360          
  361          //-------------------------------------------------------------------------------------------------------
             -------------
  362          // å‡½æ•°ç®€ä»‹     åˆå§‹åŒ– IMU963RA
  363          // å‚æ•°è¯´æ˜     void
  364          // è¿”å›å‚æ•°     uint8           1-åˆå§‹åŒ–å¤±è´¥ 0-åˆå§‹åŒ–æˆåŠŸ
  365          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_init();
  366          // å¤‡æ³¨ä¿¡æ¯
  367          //-------------------------------------------------------------------------------------------------------
             -------------
  368          uint8 imu963ra_init (void)
  369          {
  370   1          uint8 return_state = 0;
  371   1          system_delay_ms(10);                                                        // ä¸Šç”µå»¶æ—¶
  372   1          
  373   1      #if IMU963RA_USE_SOFT_IIC
                   soft_iic_init(&imu963ra_iic_struct, IMU963RA_DEV_ADDR, IMU963RA_SOFT_IIC_DELAY, IMU963RA_SCL_PIN, IMU
             -963RA_SDA_PIN);
               #else
  376   1          spi_init(IMU963RA_SPI, SPI_MODE0, IMU963RA_SPI_SPEED, IMU963RA_SPC_PIN, IMU963RA_SDI_PIN, IMU963RA_SD
             -O_PIN, SPI_CS_NULL);
  377   1          gpio_init(IMU963RA_CS_PIN, GPO, GPIO_HIGH, GPO_PUSH_PULL);
  378   1      #endif
  379   1          
  380   1          do
  381   1          {
  382   2              imu963ra_write_acc_gyro_register(IMU963RA_FUNC_CFG_ACCESS, 0x00);       // å…³é—­HUBå¯„å­˜å™¨è®¿é
             -—®
  383   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL3_C, 0x01);               // å¤ä½è®¾å¤‡
  384   2              system_delay_ms(2);
  385   2              imu963ra_write_acc_gyro_register(IMU963RA_FUNC_CFG_ACCESS, 0x00);       // å…³é—­HUBå¯„å­˜å™¨è®¿é
             -—®
  386   2              
  387   2              if(imu963ra_acc_gyro_self_check())
  388   2              {
  389   3                  printf( "IMU963RA acc and gyro self check error.");
  390   3                  return_state = 1;
  391   3                  break;
  392   3              }
  393   2              
  394   2              imu963ra_write_acc_gyro_register(IMU963RA_INT1_CTRL, 0x03);             // å¼€å¯é™€èºä»ª åŠ é€Ÿ
             -åº¦æ•°æ®å°±ç»ªä¸­æ–­
  395   2              
  396   2              // IMU963RA_CTRL1_XL å¯„å­˜å™¨
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 07/05/25  16:28:03  PAGE 8   

  397   2              // è®¾ç½®ä¸º 0x30 åŠ é€Ÿåº¦é‡ç¨‹ä¸º Â±2  G    è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ®é™¤ä»¥ 16393  å¯ä»¥
             -è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ g(m/s^2)
  398   2              // è®¾ç½®ä¸º 0x38 åŠ é€Ÿåº¦é‡ç¨‹ä¸º Â±4  G    è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ®é™¤ä»¥ 8197   å¯ä»¥
             -è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ g(m/s^2)
  399   2              // è®¾ç½®ä¸º 0x3C åŠ é€Ÿåº¦é‡ç¨‹ä¸º Â±8  G    è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ®é™¤ä»¥ 4098   å¯ä»¥
             -è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ g(m/s^2)
  400   2              // è®¾ç½®ä¸º 0x34 åŠ é€Ÿåº¦é‡ç¨‹ä¸º Â±16 G    è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ®é™¤ä»¥ 2049   å¯ä»¥
             -è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ g(m/s^2)
  401   2              switch(IMU963RA_ACC_SAMPLE_DEFAULT)
  402   2              {
  403   3                  default:
  404   3                  {
  405   4                      printf( "IMU963RA_ACC_SAMPLE_DEFAULT set error.\r\n");
  406   4                      return_state = 1;
  407   4                  }
  408   3                  break;
  409   3                  
  410   3                  case IMU963RA_ACC_SAMPLE_SGN_2G:
  411   3                  {
  412   4                      imu963ra_write_acc_gyro_register(IMU963RA_CTRL1_XL, 0x30);
  413   4                      imu963ra_transition_factor[0] = 16393;
  414   4                  }
  415   3                  break;
  416   3                  
  417   3                  case IMU963RA_ACC_SAMPLE_SGN_4G:
  418   3                  {
  419   4                      imu963ra_write_acc_gyro_register(IMU963RA_CTRL1_XL, 0x38);
  420   4                      imu963ra_transition_factor[0] = 8197;
  421   4                  }
  422   3                  break;
  423   3                  
  424   3                  case IMU963RA_ACC_SAMPLE_SGN_8G:
  425   3                  {
  426   4                      imu963ra_write_acc_gyro_register(IMU963RA_CTRL1_XL, 0x3C);
  427   4                      imu963ra_transition_factor[0] = 4098;
  428   4                  }
  429   3                  break;
  430   3                  
  431   3                  case IMU963RA_ACC_SAMPLE_SGN_16G:
  432   3                  {
  433   4                      imu963ra_write_acc_gyro_register(IMU963RA_CTRL1_XL, 0x34);
  434   4                      imu963ra_transition_factor[0] = 2049;
  435   4                  }
  436   3                  break;
  437   3              }
  438   2              
  439   2              if(1 == return_state)
  440   2              {
  441   3                  break;
  442   3              }
  443   2              
  444   2              // IMU963RA_CTRL2_G å¯„å­˜å™¨
  445   2              // è®¾ç½®ä¸º 0x52 é™€èºä»ªé‡ç¨‹ä¸º Â±125  dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 228.6   å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸º Â°/s
  446   2              // è®¾ç½®ä¸º 0x50 é™€èºä»ªé‡ç¨‹ä¸º Â±250  dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 114.3   å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸º Â°/s
  447   2              // è®¾ç½®ä¸º 0x54 é™€èºä»ªé‡ç¨‹ä¸º Â±500  dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 57.1    å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸º Â°/s
  448   2              // è®¾ç½®ä¸º 0x58 é™€èºä»ªé‡ç¨‹ä¸º Â±1000 dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 28.6    å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸º Â°/s
  449   2              // è®¾ç½®ä¸º 0x5C é™€èºä»ªé‡ç¨‹ä¸º Â±2000 dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 14.3    å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸º Â°/s
  450   2              // è®¾ç½®ä¸º 0x51 é™€èºä»ªé‡ç¨‹ä¸º Â±4000 dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 7.1     å¯ä
             -»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸º Â°/s
  451   2              switch(IMU963RA_GYRO_SAMPLE_DEFAULT)
  452   2              {
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 07/05/25  16:28:03  PAGE 9   

  453   3                  default:
  454   3                  {
  455   4                      printf( "IMU963RA_GYRO_SAMPLE_DEFAULT set error.\r\n");
  456   4                      return_state = 1;
  457   4                  }
  458   3                  break;
  459   3                  
  460   3                  case IMU963RA_GYRO_SAMPLE_SGN_125DPS:
  461   3                  {
  462   4                      imu963ra_write_acc_gyro_register(IMU963RA_CTRL2_G, 0x52);
  463   4                      imu963ra_transition_factor[1] = 228.6;
  464   4                  }
  465   3                  break;
  466   3                  
  467   3                  case IMU963RA_GYRO_SAMPLE_SGN_250DPS:
  468   3                  {
  469   4                      imu963ra_write_acc_gyro_register(IMU963RA_CTRL2_G, 0x50);
  470   4                      imu963ra_transition_factor[1] = 114.3;
  471   4                  }
  472   3                  break;
  473   3                  
  474   3                  case IMU963RA_GYRO_SAMPLE_SGN_500DPS:
  475   3                  {
  476   4                      imu963ra_write_acc_gyro_register(IMU963RA_CTRL2_G, 0x54);
  477   4                      imu963ra_transition_factor[1] = 57.1;
  478   4                  }
  479   3                  break;
  480   3                  
  481   3                  case IMU963RA_GYRO_SAMPLE_SGN_1000DPS:
  482   3                  {
  483   4                      imu963ra_write_acc_gyro_register(IMU963RA_CTRL2_G, 0x58);
  484   4                      imu963ra_transition_factor[1] = 28.6;
  485   4                  }
  486   3                  break;
  487   3                  
  488   3                  case IMU963RA_GYRO_SAMPLE_SGN_2000DPS:
  489   3                  {
  490   4                      imu963ra_write_acc_gyro_register(IMU963RA_CTRL2_G, 0x5C);
  491   4                      imu963ra_transition_factor[1] = 14.3;
  492   4                  }
  493   3                  break;
  494   3                  
  495   3                  case IMU963RA_GYRO_SAMPLE_SGN_4000DPS:
  496   3                  {
  497   4                      imu963ra_write_acc_gyro_register(IMU963RA_CTRL2_G, 0x51);
  498   4                      imu963ra_transition_factor[1] = 7.1;
  499   4                  }
  500   3                  break;
  501   3              }
  502   2              
  503   2              if(1 == return_state)
  504   2              {
  505   3                  break;
  506   3              }
  507   2              
  508   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL3_C, 0x44);               // ä½¿èƒ½é™€èºä»ªæ•°å­—ä
             -½é€šæ»¤æ³¢å™¨
  509   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL4_C, 0x02);               // ä½¿èƒ½æ•°å­—ä½é€šæ»¤æ
             -³¢å™¨
  510   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL5_C, 0x00);               // åŠ é€Ÿåº¦è®¡ä¸é™€èºä
             -»ªå››èˆäº”å…¥
  511   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL6_C, 0x00);               // å¼€å¯åŠ é€Ÿåº¦è®¡é«˜æ
             -€§èƒ½æ¨¡å¼ é™€èºä»ªä½é€šæ»¤æ³¢ 133hz
  512   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL7_G, 0x00);               // å¼€å¯é™€èºä»ªé«˜æ€§è
             -ƒ½æ¨¡å¼ å…³é—­é«˜é€šæ»¤æ³¢
  513   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL9_XL, 0x01);              // å…³é—­I3Cæ¥å£
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 07/05/25  16:28:03  PAGE 10  

  514   2              
  515   2              imu963ra_write_acc_gyro_register(IMU963RA_FUNC_CFG_ACCESS, 0x40);       // å¼€å¯HUBå¯„å­˜å™¨è®¿é
             -—® ç”¨äºé…ç½®åœ°ç£è®¡
  516   2              imu963ra_write_acc_gyro_register(IMU963RA_MASTER_CONFIG, 0x80);         // å¤ä½I2Cä¸»æœº
  517   2              system_delay_ms(2);
  518   2              imu963ra_write_acc_gyro_register(IMU963RA_MASTER_CONFIG, 0x00);         // æ¸…é™¤å¤ä½æ ‡å¿—
  519   2              system_delay_ms(2);
  520   2              
  521   2              imu963ra_write_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_CONTROL2, 0x80);// å¤ä½è¿æ¥çš„å¤–
             -è®¾
  522   2              system_delay_ms(2);
  523   2              imu963ra_write_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_CONTROL2, 0x00);
  524   2              system_delay_ms(2);
  525   2              
  526   2              if(imu963ra_mag_self_check())
  527   2              {
  528   3                  printf( "IMU963RA mag self check error.\r\n");
  529   3                  return_state = 1;
  530   3                  break;
  531   3              }
  532   2              
  533   2              // IMU963RA_MAG_ADDR å¯„å­˜å™¨
  534   2              // è®¾ç½®ä¸º 0x09 ç£åŠ›è®¡é‡ç¨‹ä¸º 2G   è·å–åˆ°çš„ç£åŠ›è®¡æ•°æ®é™¤ä»¥ 12000   å¯ä»¥è½¬åŒ–ä
             -¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ G(é«˜æ–¯)
  535   2              // è®¾ç½®ä¸º 0x19 ç£åŠ›è®¡é‡ç¨‹ä¸º 8G   è·å–åˆ°çš„ç£åŠ›è®¡æ•°æ®é™¤ä»¥ 3000    å¯ä»¥è½¬åŒ–ä
             -¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ G(é«˜æ–¯)
  536   2              switch(IMU963RA_MAG_SAMPLE_DEFAULT)
  537   2              {
  538   3                  default:
  539   3                  {
  540   4                      printf( "IMU963RA_MAG_SAMPLE_DEFAULT set error.\r\n");
  541   4                      return_state = 1;
  542   4                  }
  543   3                  break;
  544   3                  
  545   3                  case IMU963RA_MAG_SAMPLE_2G:
  546   3                  {
  547   4                      imu963ra_write_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_CONTROL1, 0x09);
  548   4                      imu963ra_transition_factor[2] = 12000;
  549   4                  }
  550   3                  break;
  551   3                  
  552   3                  case IMU963RA_MAG_SAMPLE_8G:
  553   3                  {
  554   4                      imu963ra_write_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_CONTROL1, 0x19);
  555   4                      imu963ra_transition_factor[2] = 3000;
  556   4                  }
  557   3                  break;
  558   3              }
  559   2              
  560   2              if(1 == return_state)
  561   2              {
  562   3                  break;
  563   3              }
  564   2              
  565   2              imu963ra_write_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_FBR, 0x01);
  566   2              imu963ra_connect_mag(IMU963RA_MAG_ADDR, IMU963RA_MAG_OUTX_L);
  567   2              
  568   2              imu963ra_write_acc_gyro_register(IMU963RA_FUNC_CFG_ACCESS, 0x00);       // å…³é—­HUBå¯„å­˜å™¨è®¿é
             -—®
  569   2              
  570   2              system_delay_ms(20);                                                    // ç­‰å¾…ç£åŠ›è®¡è·å–æ
             -•°æ®
  571   2          }
  572   1          while(0);
  573   1          
C251 COMPILER V5.60.0,  zf_device_imu963ra                                                 07/05/25  16:28:03  PAGE 11  

  574   1          return return_state;
  575   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1803     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        83     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       277     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
